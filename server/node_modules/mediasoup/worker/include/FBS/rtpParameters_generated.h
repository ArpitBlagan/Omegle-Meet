// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_RTPPARAMETERS_FBS_RTPPARAMETERS_H_
#define FLATBUFFERS_GENERATED_RTPPARAMETERS_FBS_RTPPARAMETERS_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 3,
             "Non-compatible flatbuffers version included");

namespace FBS {
namespace RtpParameters {

struct Boolean;
struct BooleanBuilder;

struct Integer32;
struct Integer32Builder;

struct Integer32Array;
struct Integer32ArrayBuilder;

struct Double;
struct DoubleBuilder;

struct String;
struct StringBuilder;

struct Parameter;
struct ParameterBuilder;

struct RtcpFeedback;
struct RtcpFeedbackBuilder;

struct RtpCodecParameters;
struct RtpCodecParametersBuilder;

struct RtpHeaderExtensionParameters;
struct RtpHeaderExtensionParametersBuilder;

struct Rtx;
struct RtxBuilder;

struct RtpEncodingParameters;
struct RtpEncodingParametersBuilder;

struct RtcpParameters;
struct RtcpParametersBuilder;

struct RtpParameters;
struct RtpParametersBuilder;

struct CodecMapping;
struct CodecMappingBuilder;

struct EncodingMapping;
struct EncodingMappingBuilder;

struct RtpMapping;
struct RtpMappingBuilder;

inline const ::flatbuffers::TypeTable *BooleanTypeTable();

inline const ::flatbuffers::TypeTable *Integer32TypeTable();

inline const ::flatbuffers::TypeTable *Integer32ArrayTypeTable();

inline const ::flatbuffers::TypeTable *DoubleTypeTable();

inline const ::flatbuffers::TypeTable *StringTypeTable();

inline const ::flatbuffers::TypeTable *ParameterTypeTable();

inline const ::flatbuffers::TypeTable *RtcpFeedbackTypeTable();

inline const ::flatbuffers::TypeTable *RtpCodecParametersTypeTable();

inline const ::flatbuffers::TypeTable *RtpHeaderExtensionParametersTypeTable();

inline const ::flatbuffers::TypeTable *RtxTypeTable();

inline const ::flatbuffers::TypeTable *RtpEncodingParametersTypeTable();

inline const ::flatbuffers::TypeTable *RtcpParametersTypeTable();

inline const ::flatbuffers::TypeTable *RtpParametersTypeTable();

inline const ::flatbuffers::TypeTable *CodecMappingTypeTable();

inline const ::flatbuffers::TypeTable *EncodingMappingTypeTable();

inline const ::flatbuffers::TypeTable *RtpMappingTypeTable();

enum class MediaKind : uint8_t {
  ALL = 0,
  AUDIO = 1,
  VIDEO = 2,
  MIN = ALL,
  MAX = VIDEO
};

inline const MediaKind (&EnumValuesMediaKind())[3] {
  static const MediaKind values[] = {
    MediaKind::ALL,
    MediaKind::AUDIO,
    MediaKind::VIDEO
  };
  return values;
}

inline const char * const *EnumNamesMediaKind() {
  static const char * const names[4] = {
    "ALL",
    "AUDIO",
    "VIDEO",
    nullptr
  };
  return names;
}

inline const char *EnumNameMediaKind(MediaKind e) {
  if (::flatbuffers::IsOutRange(e, MediaKind::ALL, MediaKind::VIDEO)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMediaKind()[index];
}

enum class Type : uint8_t {
  NONE = 0,
  SIMPLE = 1,
  SIMULCAST = 2,
  SVC = 3,
  PIPE = 4,
  MIN = NONE,
  MAX = PIPE
};

inline const Type (&EnumValuesType())[5] {
  static const Type values[] = {
    Type::NONE,
    Type::SIMPLE,
    Type::SIMULCAST,
    Type::SVC,
    Type::PIPE
  };
  return values;
}

inline const char * const *EnumNamesType() {
  static const char * const names[6] = {
    "NONE",
    "SIMPLE",
    "SIMULCAST",
    "SVC",
    "PIPE",
    nullptr
  };
  return names;
}

inline const char *EnumNameType(Type e) {
  if (::flatbuffers::IsOutRange(e, Type::NONE, Type::PIPE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesType()[index];
}

enum class Value : uint8_t {
  NONE = 0,
  Boolean = 1,
  Integer32 = 2,
  Double = 3,
  String = 4,
  Integer32Array = 5,
  MIN = NONE,
  MAX = Integer32Array
};

inline const Value (&EnumValuesValue())[6] {
  static const Value values[] = {
    Value::NONE,
    Value::Boolean,
    Value::Integer32,
    Value::Double,
    Value::String,
    Value::Integer32Array
  };
  return values;
}

inline const char * const *EnumNamesValue() {
  static const char * const names[7] = {
    "NONE",
    "Boolean",
    "Integer32",
    "Double",
    "String",
    "Integer32Array",
    nullptr
  };
  return names;
}

inline const char *EnumNameValue(Value e) {
  if (::flatbuffers::IsOutRange(e, Value::NONE, Value::Integer32Array)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesValue()[index];
}

template<typename T> struct ValueTraits {
  static const Value enum_value = Value::NONE;
};

template<> struct ValueTraits<FBS::RtpParameters::Boolean> {
  static const Value enum_value = Value::Boolean;
};

template<> struct ValueTraits<FBS::RtpParameters::Integer32> {
  static const Value enum_value = Value::Integer32;
};

template<> struct ValueTraits<FBS::RtpParameters::Double> {
  static const Value enum_value = Value::Double;
};

template<> struct ValueTraits<FBS::RtpParameters::String> {
  static const Value enum_value = Value::String;
};

template<> struct ValueTraits<FBS::RtpParameters::Integer32Array> {
  static const Value enum_value = Value::Integer32Array;
};

bool VerifyValue(::flatbuffers::Verifier &verifier, const void *obj, Value type);
bool VerifyValueVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<Value> *types);

struct Boolean FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BooleanBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return BooleanTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  uint8_t value() const {
    return GetField<uint8_t>(VT_VALUE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_VALUE, 1) &&
           verifier.EndTable();
  }
};

struct BooleanBuilder {
  typedef Boolean Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(uint8_t value) {
    fbb_.AddElement<uint8_t>(Boolean::VT_VALUE, value, 0);
  }
  explicit BooleanBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Boolean> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Boolean>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Boolean> CreateBoolean(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t value = 0) {
  BooleanBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct Integer32 FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Integer32Builder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return Integer32TypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  int32_t value() const {
    return GetField<int32_t>(VT_VALUE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_VALUE, 4) &&
           verifier.EndTable();
  }
};

struct Integer32Builder {
  typedef Integer32 Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(int32_t value) {
    fbb_.AddElement<int32_t>(Integer32::VT_VALUE, value, 0);
  }
  explicit Integer32Builder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Integer32> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Integer32>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Integer32> CreateInteger32(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t value = 0) {
  Integer32Builder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct Integer32Array FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Integer32ArrayBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return Integer32ArrayTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  const ::flatbuffers::Vector<int32_t> *value() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_VALUE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyVector(value()) &&
           verifier.EndTable();
  }
};

struct Integer32ArrayBuilder {
  typedef Integer32Array Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> value) {
    fbb_.AddOffset(Integer32Array::VT_VALUE, value);
  }
  explicit Integer32ArrayBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Integer32Array> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Integer32Array>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Integer32Array> CreateInteger32Array(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> value = 0) {
  Integer32ArrayBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Integer32Array> CreateInteger32ArrayDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *value = nullptr) {
  auto value__ = value ? _fbb.CreateVector<int32_t>(*value) : 0;
  return FBS::RtpParameters::CreateInteger32Array(
      _fbb,
      value__);
}

struct Double FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DoubleBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return DoubleTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  double value() const {
    return GetField<double>(VT_VALUE, 0.0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_VALUE, 8) &&
           verifier.EndTable();
  }
};

struct DoubleBuilder {
  typedef Double Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(double value) {
    fbb_.AddElement<double>(Double::VT_VALUE, value, 0.0);
  }
  explicit DoubleBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Double> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Double>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Double> CreateDouble(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double value = 0.0) {
  DoubleBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct String FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StringBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return StringTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  const ::flatbuffers::String *value() const {
    return GetPointer<const ::flatbuffers::String *>(VT_VALUE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_VALUE) &&
           verifier.VerifyString(value()) &&
           verifier.EndTable();
  }
};

struct StringBuilder {
  typedef String Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(::flatbuffers::Offset<::flatbuffers::String> value) {
    fbb_.AddOffset(String::VT_VALUE, value);
  }
  explicit StringBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<String> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<String>(end);
    fbb_.Required(o, String::VT_VALUE);
    return o;
  }
};

inline ::flatbuffers::Offset<String> CreateString(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> value = 0) {
  StringBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<String> CreateStringDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *value = nullptr) {
  auto value__ = value ? _fbb.CreateString(value) : 0;
  return FBS::RtpParameters::CreateString(
      _fbb,
      value__);
}

struct Parameter FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ParameterBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ParameterTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_VALUE_TYPE = 6,
    VT_VALUE = 8
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  FBS::RtpParameters::Value value_type() const {
    return static_cast<FBS::RtpParameters::Value>(GetField<uint8_t>(VT_VALUE_TYPE, 0));
  }
  const void *value() const {
    return GetPointer<const void *>(VT_VALUE);
  }
  template<typename T> const T *value_as() const;
  const FBS::RtpParameters::Boolean *value_as_Boolean() const {
    return value_type() == FBS::RtpParameters::Value::Boolean ? static_cast<const FBS::RtpParameters::Boolean *>(value()) : nullptr;
  }
  const FBS::RtpParameters::Integer32 *value_as_Integer32() const {
    return value_type() == FBS::RtpParameters::Value::Integer32 ? static_cast<const FBS::RtpParameters::Integer32 *>(value()) : nullptr;
  }
  const FBS::RtpParameters::Double *value_as_Double() const {
    return value_type() == FBS::RtpParameters::Value::Double ? static_cast<const FBS::RtpParameters::Double *>(value()) : nullptr;
  }
  const FBS::RtpParameters::String *value_as_String() const {
    return value_type() == FBS::RtpParameters::Value::String ? static_cast<const FBS::RtpParameters::String *>(value()) : nullptr;
  }
  const FBS::RtpParameters::Integer32Array *value_as_Integer32Array() const {
    return value_type() == FBS::RtpParameters::Value::Integer32Array ? static_cast<const FBS::RtpParameters::Integer32Array *>(value()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint8_t>(verifier, VT_VALUE_TYPE, 1) &&
           VerifyOffsetRequired(verifier, VT_VALUE) &&
           VerifyValue(verifier, value(), value_type()) &&
           verifier.EndTable();
  }
};

template<> inline const FBS::RtpParameters::Boolean *Parameter::value_as<FBS::RtpParameters::Boolean>() const {
  return value_as_Boolean();
}

template<> inline const FBS::RtpParameters::Integer32 *Parameter::value_as<FBS::RtpParameters::Integer32>() const {
  return value_as_Integer32();
}

template<> inline const FBS::RtpParameters::Double *Parameter::value_as<FBS::RtpParameters::Double>() const {
  return value_as_Double();
}

template<> inline const FBS::RtpParameters::String *Parameter::value_as<FBS::RtpParameters::String>() const {
  return value_as_String();
}

template<> inline const FBS::RtpParameters::Integer32Array *Parameter::value_as<FBS::RtpParameters::Integer32Array>() const {
  return value_as_Integer32Array();
}

struct ParameterBuilder {
  typedef Parameter Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Parameter::VT_NAME, name);
  }
  void add_value_type(FBS::RtpParameters::Value value_type) {
    fbb_.AddElement<uint8_t>(Parameter::VT_VALUE_TYPE, static_cast<uint8_t>(value_type), 0);
  }
  void add_value(::flatbuffers::Offset<void> value) {
    fbb_.AddOffset(Parameter::VT_VALUE, value);
  }
  explicit ParameterBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Parameter> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Parameter>(end);
    fbb_.Required(o, Parameter::VT_NAME);
    fbb_.Required(o, Parameter::VT_VALUE);
    return o;
  }
};

inline ::flatbuffers::Offset<Parameter> CreateParameter(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    FBS::RtpParameters::Value value_type = FBS::RtpParameters::Value::NONE,
    ::flatbuffers::Offset<void> value = 0) {
  ParameterBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_name(name);
  builder_.add_value_type(value_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Parameter> CreateParameterDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    FBS::RtpParameters::Value value_type = FBS::RtpParameters::Value::NONE,
    ::flatbuffers::Offset<void> value = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return FBS::RtpParameters::CreateParameter(
      _fbb,
      name__,
      value_type,
      value);
}

struct RtcpFeedback FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RtcpFeedbackBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return RtcpFeedbackTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_PARAMETER = 6
  };
  const ::flatbuffers::String *type() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TYPE);
  }
  const ::flatbuffers::String *parameter() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PARAMETER);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_TYPE) &&
           verifier.VerifyString(type()) &&
           VerifyOffsetRequired(verifier, VT_PARAMETER) &&
           verifier.VerifyString(parameter()) &&
           verifier.EndTable();
  }
};

struct RtcpFeedbackBuilder {
  typedef RtcpFeedback Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_type(::flatbuffers::Offset<::flatbuffers::String> type) {
    fbb_.AddOffset(RtcpFeedback::VT_TYPE, type);
  }
  void add_parameter(::flatbuffers::Offset<::flatbuffers::String> parameter) {
    fbb_.AddOffset(RtcpFeedback::VT_PARAMETER, parameter);
  }
  explicit RtcpFeedbackBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RtcpFeedback> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RtcpFeedback>(end);
    fbb_.Required(o, RtcpFeedback::VT_TYPE);
    fbb_.Required(o, RtcpFeedback::VT_PARAMETER);
    return o;
  }
};

inline ::flatbuffers::Offset<RtcpFeedback> CreateRtcpFeedback(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> type = 0,
    ::flatbuffers::Offset<::flatbuffers::String> parameter = 0) {
  RtcpFeedbackBuilder builder_(_fbb);
  builder_.add_parameter(parameter);
  builder_.add_type(type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<RtcpFeedback> CreateRtcpFeedbackDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *type = nullptr,
    const char *parameter = nullptr) {
  auto type__ = type ? _fbb.CreateString(type) : 0;
  auto parameter__ = parameter ? _fbb.CreateString(parameter) : 0;
  return FBS::RtpParameters::CreateRtcpFeedback(
      _fbb,
      type__,
      parameter__);
}

struct RtpCodecParameters FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RtpCodecParametersBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return RtpCodecParametersTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MIMETYPE = 4,
    VT_PAYLOADTYPE = 6,
    VT_CLOCKRATE = 8,
    VT_CHANNELS = 10,
    VT_PARAMETERS = 12,
    VT_RTCPFEEDBACK = 14
  };
  const ::flatbuffers::String *mimeType() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MIMETYPE);
  }
  uint8_t payloadType() const {
    return GetField<uint8_t>(VT_PAYLOADTYPE, 0);
  }
  uint32_t clockRate() const {
    return GetField<uint32_t>(VT_CLOCKRATE, 0);
  }
  ::flatbuffers::Optional<uint8_t> channels() const {
    return GetOptional<uint8_t, uint8_t>(VT_CHANNELS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<FBS::RtpParameters::Parameter>> *parameters() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<FBS::RtpParameters::Parameter>> *>(VT_PARAMETERS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<FBS::RtpParameters::RtcpFeedback>> *rtcpFeedback() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<FBS::RtpParameters::RtcpFeedback>> *>(VT_RTCPFEEDBACK);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_MIMETYPE) &&
           verifier.VerifyString(mimeType()) &&
           VerifyField<uint8_t>(verifier, VT_PAYLOADTYPE, 1) &&
           VerifyField<uint32_t>(verifier, VT_CLOCKRATE, 4) &&
           VerifyField<uint8_t>(verifier, VT_CHANNELS, 1) &&
           VerifyOffset(verifier, VT_PARAMETERS) &&
           verifier.VerifyVector(parameters()) &&
           verifier.VerifyVectorOfTables(parameters()) &&
           VerifyOffset(verifier, VT_RTCPFEEDBACK) &&
           verifier.VerifyVector(rtcpFeedback()) &&
           verifier.VerifyVectorOfTables(rtcpFeedback()) &&
           verifier.EndTable();
  }
};

struct RtpCodecParametersBuilder {
  typedef RtpCodecParameters Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_mimeType(::flatbuffers::Offset<::flatbuffers::String> mimeType) {
    fbb_.AddOffset(RtpCodecParameters::VT_MIMETYPE, mimeType);
  }
  void add_payloadType(uint8_t payloadType) {
    fbb_.AddElement<uint8_t>(RtpCodecParameters::VT_PAYLOADTYPE, payloadType, 0);
  }
  void add_clockRate(uint32_t clockRate) {
    fbb_.AddElement<uint32_t>(RtpCodecParameters::VT_CLOCKRATE, clockRate, 0);
  }
  void add_channels(uint8_t channels) {
    fbb_.AddElement<uint8_t>(RtpCodecParameters::VT_CHANNELS, channels);
  }
  void add_parameters(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<FBS::RtpParameters::Parameter>>> parameters) {
    fbb_.AddOffset(RtpCodecParameters::VT_PARAMETERS, parameters);
  }
  void add_rtcpFeedback(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<FBS::RtpParameters::RtcpFeedback>>> rtcpFeedback) {
    fbb_.AddOffset(RtpCodecParameters::VT_RTCPFEEDBACK, rtcpFeedback);
  }
  explicit RtpCodecParametersBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RtpCodecParameters> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RtpCodecParameters>(end);
    fbb_.Required(o, RtpCodecParameters::VT_MIMETYPE);
    return o;
  }
};

inline ::flatbuffers::Offset<RtpCodecParameters> CreateRtpCodecParameters(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> mimeType = 0,
    uint8_t payloadType = 0,
    uint32_t clockRate = 0,
    ::flatbuffers::Optional<uint8_t> channels = ::flatbuffers::nullopt,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<FBS::RtpParameters::Parameter>>> parameters = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<FBS::RtpParameters::RtcpFeedback>>> rtcpFeedback = 0) {
  RtpCodecParametersBuilder builder_(_fbb);
  builder_.add_rtcpFeedback(rtcpFeedback);
  builder_.add_parameters(parameters);
  builder_.add_clockRate(clockRate);
  builder_.add_mimeType(mimeType);
  if(channels) { builder_.add_channels(*channels); }
  builder_.add_payloadType(payloadType);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<RtpCodecParameters> CreateRtpCodecParametersDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *mimeType = nullptr,
    uint8_t payloadType = 0,
    uint32_t clockRate = 0,
    ::flatbuffers::Optional<uint8_t> channels = ::flatbuffers::nullopt,
    const std::vector<::flatbuffers::Offset<FBS::RtpParameters::Parameter>> *parameters = nullptr,
    const std::vector<::flatbuffers::Offset<FBS::RtpParameters::RtcpFeedback>> *rtcpFeedback = nullptr) {
  auto mimeType__ = mimeType ? _fbb.CreateString(mimeType) : 0;
  auto parameters__ = parameters ? _fbb.CreateVector<::flatbuffers::Offset<FBS::RtpParameters::Parameter>>(*parameters) : 0;
  auto rtcpFeedback__ = rtcpFeedback ? _fbb.CreateVector<::flatbuffers::Offset<FBS::RtpParameters::RtcpFeedback>>(*rtcpFeedback) : 0;
  return FBS::RtpParameters::CreateRtpCodecParameters(
      _fbb,
      mimeType__,
      payloadType,
      clockRate,
      channels,
      parameters__,
      rtcpFeedback__);
}

struct RtpHeaderExtensionParameters FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RtpHeaderExtensionParametersBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return RtpHeaderExtensionParametersTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_URI = 4,
    VT_ID = 6,
    VT_ENCRYPT = 8,
    VT_PARAMETERS = 10
  };
  const ::flatbuffers::String *uri() const {
    return GetPointer<const ::flatbuffers::String *>(VT_URI);
  }
  uint8_t id() const {
    return GetField<uint8_t>(VT_ID, 0);
  }
  bool encrypt() const {
    return GetField<uint8_t>(VT_ENCRYPT, 0) != 0;
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<FBS::RtpParameters::Parameter>> *parameters() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<FBS::RtpParameters::Parameter>> *>(VT_PARAMETERS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_URI) &&
           verifier.VerifyString(uri()) &&
           VerifyField<uint8_t>(verifier, VT_ID, 1) &&
           VerifyField<uint8_t>(verifier, VT_ENCRYPT, 1) &&
           VerifyOffset(verifier, VT_PARAMETERS) &&
           verifier.VerifyVector(parameters()) &&
           verifier.VerifyVectorOfTables(parameters()) &&
           verifier.EndTable();
  }
};

struct RtpHeaderExtensionParametersBuilder {
  typedef RtpHeaderExtensionParameters Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_uri(::flatbuffers::Offset<::flatbuffers::String> uri) {
    fbb_.AddOffset(RtpHeaderExtensionParameters::VT_URI, uri);
  }
  void add_id(uint8_t id) {
    fbb_.AddElement<uint8_t>(RtpHeaderExtensionParameters::VT_ID, id, 0);
  }
  void add_encrypt(bool encrypt) {
    fbb_.AddElement<uint8_t>(RtpHeaderExtensionParameters::VT_ENCRYPT, static_cast<uint8_t>(encrypt), 0);
  }
  void add_parameters(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<FBS::RtpParameters::Parameter>>> parameters) {
    fbb_.AddOffset(RtpHeaderExtensionParameters::VT_PARAMETERS, parameters);
  }
  explicit RtpHeaderExtensionParametersBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RtpHeaderExtensionParameters> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RtpHeaderExtensionParameters>(end);
    fbb_.Required(o, RtpHeaderExtensionParameters::VT_URI);
    return o;
  }
};

inline ::flatbuffers::Offset<RtpHeaderExtensionParameters> CreateRtpHeaderExtensionParameters(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> uri = 0,
    uint8_t id = 0,
    bool encrypt = false,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<FBS::RtpParameters::Parameter>>> parameters = 0) {
  RtpHeaderExtensionParametersBuilder builder_(_fbb);
  builder_.add_parameters(parameters);
  builder_.add_uri(uri);
  builder_.add_encrypt(encrypt);
  builder_.add_id(id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<RtpHeaderExtensionParameters> CreateRtpHeaderExtensionParametersDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *uri = nullptr,
    uint8_t id = 0,
    bool encrypt = false,
    const std::vector<::flatbuffers::Offset<FBS::RtpParameters::Parameter>> *parameters = nullptr) {
  auto uri__ = uri ? _fbb.CreateString(uri) : 0;
  auto parameters__ = parameters ? _fbb.CreateVector<::flatbuffers::Offset<FBS::RtpParameters::Parameter>>(*parameters) : 0;
  return FBS::RtpParameters::CreateRtpHeaderExtensionParameters(
      _fbb,
      uri__,
      id,
      encrypt,
      parameters__);
}

struct Rtx FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RtxBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return RtxTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SSRC = 4
  };
  uint32_t ssrc() const {
    return GetField<uint32_t>(VT_SSRC, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_SSRC, 4) &&
           verifier.EndTable();
  }
};

struct RtxBuilder {
  typedef Rtx Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_ssrc(uint32_t ssrc) {
    fbb_.AddElement<uint32_t>(Rtx::VT_SSRC, ssrc, 0);
  }
  explicit RtxBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Rtx> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Rtx>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Rtx> CreateRtx(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t ssrc = 0) {
  RtxBuilder builder_(_fbb);
  builder_.add_ssrc(ssrc);
  return builder_.Finish();
}

struct RtpEncodingParameters FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RtpEncodingParametersBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return RtpEncodingParametersTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SSRC = 4,
    VT_RID = 6,
    VT_CODECPAYLOADTYPE = 8,
    VT_RTX = 10,
    VT_DTX = 12,
    VT_SCALABILITYMODE = 14,
    VT_MAXBITRATE = 16
  };
  ::flatbuffers::Optional<uint32_t> ssrc() const {
    return GetOptional<uint32_t, uint32_t>(VT_SSRC);
  }
  const ::flatbuffers::String *rid() const {
    return GetPointer<const ::flatbuffers::String *>(VT_RID);
  }
  ::flatbuffers::Optional<uint8_t> codecPayloadType() const {
    return GetOptional<uint8_t, uint8_t>(VT_CODECPAYLOADTYPE);
  }
  const FBS::RtpParameters::Rtx *rtx() const {
    return GetPointer<const FBS::RtpParameters::Rtx *>(VT_RTX);
  }
  bool dtx() const {
    return GetField<uint8_t>(VT_DTX, 0) != 0;
  }
  const ::flatbuffers::String *scalabilityMode() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SCALABILITYMODE);
  }
  ::flatbuffers::Optional<uint32_t> maxBitrate() const {
    return GetOptional<uint32_t, uint32_t>(VT_MAXBITRATE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_SSRC, 4) &&
           VerifyOffset(verifier, VT_RID) &&
           verifier.VerifyString(rid()) &&
           VerifyField<uint8_t>(verifier, VT_CODECPAYLOADTYPE, 1) &&
           VerifyOffset(verifier, VT_RTX) &&
           verifier.VerifyTable(rtx()) &&
           VerifyField<uint8_t>(verifier, VT_DTX, 1) &&
           VerifyOffset(verifier, VT_SCALABILITYMODE) &&
           verifier.VerifyString(scalabilityMode()) &&
           VerifyField<uint32_t>(verifier, VT_MAXBITRATE, 4) &&
           verifier.EndTable();
  }
};

struct RtpEncodingParametersBuilder {
  typedef RtpEncodingParameters Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_ssrc(uint32_t ssrc) {
    fbb_.AddElement<uint32_t>(RtpEncodingParameters::VT_SSRC, ssrc);
  }
  void add_rid(::flatbuffers::Offset<::flatbuffers::String> rid) {
    fbb_.AddOffset(RtpEncodingParameters::VT_RID, rid);
  }
  void add_codecPayloadType(uint8_t codecPayloadType) {
    fbb_.AddElement<uint8_t>(RtpEncodingParameters::VT_CODECPAYLOADTYPE, codecPayloadType);
  }
  void add_rtx(::flatbuffers::Offset<FBS::RtpParameters::Rtx> rtx) {
    fbb_.AddOffset(RtpEncodingParameters::VT_RTX, rtx);
  }
  void add_dtx(bool dtx) {
    fbb_.AddElement<uint8_t>(RtpEncodingParameters::VT_DTX, static_cast<uint8_t>(dtx), 0);
  }
  void add_scalabilityMode(::flatbuffers::Offset<::flatbuffers::String> scalabilityMode) {
    fbb_.AddOffset(RtpEncodingParameters::VT_SCALABILITYMODE, scalabilityMode);
  }
  void add_maxBitrate(uint32_t maxBitrate) {
    fbb_.AddElement<uint32_t>(RtpEncodingParameters::VT_MAXBITRATE, maxBitrate);
  }
  explicit RtpEncodingParametersBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RtpEncodingParameters> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RtpEncodingParameters>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RtpEncodingParameters> CreateRtpEncodingParameters(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Optional<uint32_t> ssrc = ::flatbuffers::nullopt,
    ::flatbuffers::Offset<::flatbuffers::String> rid = 0,
    ::flatbuffers::Optional<uint8_t> codecPayloadType = ::flatbuffers::nullopt,
    ::flatbuffers::Offset<FBS::RtpParameters::Rtx> rtx = 0,
    bool dtx = false,
    ::flatbuffers::Offset<::flatbuffers::String> scalabilityMode = 0,
    ::flatbuffers::Optional<uint32_t> maxBitrate = ::flatbuffers::nullopt) {
  RtpEncodingParametersBuilder builder_(_fbb);
  if(maxBitrate) { builder_.add_maxBitrate(*maxBitrate); }
  builder_.add_scalabilityMode(scalabilityMode);
  builder_.add_rtx(rtx);
  builder_.add_rid(rid);
  if(ssrc) { builder_.add_ssrc(*ssrc); }
  builder_.add_dtx(dtx);
  if(codecPayloadType) { builder_.add_codecPayloadType(*codecPayloadType); }
  return builder_.Finish();
}

inline ::flatbuffers::Offset<RtpEncodingParameters> CreateRtpEncodingParametersDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Optional<uint32_t> ssrc = ::flatbuffers::nullopt,
    const char *rid = nullptr,
    ::flatbuffers::Optional<uint8_t> codecPayloadType = ::flatbuffers::nullopt,
    ::flatbuffers::Offset<FBS::RtpParameters::Rtx> rtx = 0,
    bool dtx = false,
    const char *scalabilityMode = nullptr,
    ::flatbuffers::Optional<uint32_t> maxBitrate = ::flatbuffers::nullopt) {
  auto rid__ = rid ? _fbb.CreateString(rid) : 0;
  auto scalabilityMode__ = scalabilityMode ? _fbb.CreateString(scalabilityMode) : 0;
  return FBS::RtpParameters::CreateRtpEncodingParameters(
      _fbb,
      ssrc,
      rid__,
      codecPayloadType,
      rtx,
      dtx,
      scalabilityMode__,
      maxBitrate);
}

struct RtcpParameters FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RtcpParametersBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return RtcpParametersTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CNAME = 4,
    VT_REDUCEDSIZE = 6
  };
  const ::flatbuffers::String *cname() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CNAME);
  }
  bool reducedSize() const {
    return GetField<uint8_t>(VT_REDUCEDSIZE, 1) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CNAME) &&
           verifier.VerifyString(cname()) &&
           VerifyField<uint8_t>(verifier, VT_REDUCEDSIZE, 1) &&
           verifier.EndTable();
  }
};

struct RtcpParametersBuilder {
  typedef RtcpParameters Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_cname(::flatbuffers::Offset<::flatbuffers::String> cname) {
    fbb_.AddOffset(RtcpParameters::VT_CNAME, cname);
  }
  void add_reducedSize(bool reducedSize) {
    fbb_.AddElement<uint8_t>(RtcpParameters::VT_REDUCEDSIZE, static_cast<uint8_t>(reducedSize), 1);
  }
  explicit RtcpParametersBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RtcpParameters> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RtcpParameters>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RtcpParameters> CreateRtcpParameters(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> cname = 0,
    bool reducedSize = true) {
  RtcpParametersBuilder builder_(_fbb);
  builder_.add_cname(cname);
  builder_.add_reducedSize(reducedSize);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<RtcpParameters> CreateRtcpParametersDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *cname = nullptr,
    bool reducedSize = true) {
  auto cname__ = cname ? _fbb.CreateString(cname) : 0;
  return FBS::RtpParameters::CreateRtcpParameters(
      _fbb,
      cname__,
      reducedSize);
}

struct RtpParameters FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RtpParametersBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return RtpParametersTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MID = 4,
    VT_CODECS = 6,
    VT_HEADEREXTENSIONS = 8,
    VT_ENCODINGS = 10,
    VT_RTCP = 12
  };
  const ::flatbuffers::String *mid() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MID);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<FBS::RtpParameters::RtpCodecParameters>> *codecs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<FBS::RtpParameters::RtpCodecParameters>> *>(VT_CODECS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<FBS::RtpParameters::RtpHeaderExtensionParameters>> *headerExtensions() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<FBS::RtpParameters::RtpHeaderExtensionParameters>> *>(VT_HEADEREXTENSIONS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<FBS::RtpParameters::RtpEncodingParameters>> *encodings() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<FBS::RtpParameters::RtpEncodingParameters>> *>(VT_ENCODINGS);
  }
  const FBS::RtpParameters::RtcpParameters *rtcp() const {
    return GetPointer<const FBS::RtpParameters::RtcpParameters *>(VT_RTCP);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MID) &&
           verifier.VerifyString(mid()) &&
           VerifyOffsetRequired(verifier, VT_CODECS) &&
           verifier.VerifyVector(codecs()) &&
           verifier.VerifyVectorOfTables(codecs()) &&
           VerifyOffsetRequired(verifier, VT_HEADEREXTENSIONS) &&
           verifier.VerifyVector(headerExtensions()) &&
           verifier.VerifyVectorOfTables(headerExtensions()) &&
           VerifyOffsetRequired(verifier, VT_ENCODINGS) &&
           verifier.VerifyVector(encodings()) &&
           verifier.VerifyVectorOfTables(encodings()) &&
           VerifyOffsetRequired(verifier, VT_RTCP) &&
           verifier.VerifyTable(rtcp()) &&
           verifier.EndTable();
  }
};

struct RtpParametersBuilder {
  typedef RtpParameters Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_mid(::flatbuffers::Offset<::flatbuffers::String> mid) {
    fbb_.AddOffset(RtpParameters::VT_MID, mid);
  }
  void add_codecs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<FBS::RtpParameters::RtpCodecParameters>>> codecs) {
    fbb_.AddOffset(RtpParameters::VT_CODECS, codecs);
  }
  void add_headerExtensions(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<FBS::RtpParameters::RtpHeaderExtensionParameters>>> headerExtensions) {
    fbb_.AddOffset(RtpParameters::VT_HEADEREXTENSIONS, headerExtensions);
  }
  void add_encodings(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<FBS::RtpParameters::RtpEncodingParameters>>> encodings) {
    fbb_.AddOffset(RtpParameters::VT_ENCODINGS, encodings);
  }
  void add_rtcp(::flatbuffers::Offset<FBS::RtpParameters::RtcpParameters> rtcp) {
    fbb_.AddOffset(RtpParameters::VT_RTCP, rtcp);
  }
  explicit RtpParametersBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RtpParameters> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RtpParameters>(end);
    fbb_.Required(o, RtpParameters::VT_CODECS);
    fbb_.Required(o, RtpParameters::VT_HEADEREXTENSIONS);
    fbb_.Required(o, RtpParameters::VT_ENCODINGS);
    fbb_.Required(o, RtpParameters::VT_RTCP);
    return o;
  }
};

inline ::flatbuffers::Offset<RtpParameters> CreateRtpParameters(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> mid = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<FBS::RtpParameters::RtpCodecParameters>>> codecs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<FBS::RtpParameters::RtpHeaderExtensionParameters>>> headerExtensions = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<FBS::RtpParameters::RtpEncodingParameters>>> encodings = 0,
    ::flatbuffers::Offset<FBS::RtpParameters::RtcpParameters> rtcp = 0) {
  RtpParametersBuilder builder_(_fbb);
  builder_.add_rtcp(rtcp);
  builder_.add_encodings(encodings);
  builder_.add_headerExtensions(headerExtensions);
  builder_.add_codecs(codecs);
  builder_.add_mid(mid);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<RtpParameters> CreateRtpParametersDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *mid = nullptr,
    const std::vector<::flatbuffers::Offset<FBS::RtpParameters::RtpCodecParameters>> *codecs = nullptr,
    const std::vector<::flatbuffers::Offset<FBS::RtpParameters::RtpHeaderExtensionParameters>> *headerExtensions = nullptr,
    const std::vector<::flatbuffers::Offset<FBS::RtpParameters::RtpEncodingParameters>> *encodings = nullptr,
    ::flatbuffers::Offset<FBS::RtpParameters::RtcpParameters> rtcp = 0) {
  auto mid__ = mid ? _fbb.CreateString(mid) : 0;
  auto codecs__ = codecs ? _fbb.CreateVector<::flatbuffers::Offset<FBS::RtpParameters::RtpCodecParameters>>(*codecs) : 0;
  auto headerExtensions__ = headerExtensions ? _fbb.CreateVector<::flatbuffers::Offset<FBS::RtpParameters::RtpHeaderExtensionParameters>>(*headerExtensions) : 0;
  auto encodings__ = encodings ? _fbb.CreateVector<::flatbuffers::Offset<FBS::RtpParameters::RtpEncodingParameters>>(*encodings) : 0;
  return FBS::RtpParameters::CreateRtpParameters(
      _fbb,
      mid__,
      codecs__,
      headerExtensions__,
      encodings__,
      rtcp);
}

struct CodecMapping FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CodecMappingBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return CodecMappingTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PAYLOADTYPE = 4,
    VT_MAPPEDPAYLOADTYPE = 6
  };
  uint8_t payloadType() const {
    return GetField<uint8_t>(VT_PAYLOADTYPE, 0);
  }
  uint8_t mappedPayloadType() const {
    return GetField<uint8_t>(VT_MAPPEDPAYLOADTYPE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_PAYLOADTYPE, 1) &&
           VerifyField<uint8_t>(verifier, VT_MAPPEDPAYLOADTYPE, 1) &&
           verifier.EndTable();
  }
};

struct CodecMappingBuilder {
  typedef CodecMapping Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_payloadType(uint8_t payloadType) {
    fbb_.AddElement<uint8_t>(CodecMapping::VT_PAYLOADTYPE, payloadType, 0);
  }
  void add_mappedPayloadType(uint8_t mappedPayloadType) {
    fbb_.AddElement<uint8_t>(CodecMapping::VT_MAPPEDPAYLOADTYPE, mappedPayloadType, 0);
  }
  explicit CodecMappingBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CodecMapping> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CodecMapping>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CodecMapping> CreateCodecMapping(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t payloadType = 0,
    uint8_t mappedPayloadType = 0) {
  CodecMappingBuilder builder_(_fbb);
  builder_.add_mappedPayloadType(mappedPayloadType);
  builder_.add_payloadType(payloadType);
  return builder_.Finish();
}

struct EncodingMapping FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef EncodingMappingBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return EncodingMappingTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RID = 4,
    VT_SSRC = 6,
    VT_SCALABILITYMODE = 8,
    VT_MAPPEDSSRC = 10
  };
  const ::flatbuffers::String *rid() const {
    return GetPointer<const ::flatbuffers::String *>(VT_RID);
  }
  ::flatbuffers::Optional<uint32_t> ssrc() const {
    return GetOptional<uint32_t, uint32_t>(VT_SSRC);
  }
  const ::flatbuffers::String *scalabilityMode() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SCALABILITYMODE);
  }
  uint32_t mappedSsrc() const {
    return GetField<uint32_t>(VT_MAPPEDSSRC, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_RID) &&
           verifier.VerifyString(rid()) &&
           VerifyField<uint32_t>(verifier, VT_SSRC, 4) &&
           VerifyOffset(verifier, VT_SCALABILITYMODE) &&
           verifier.VerifyString(scalabilityMode()) &&
           VerifyField<uint32_t>(verifier, VT_MAPPEDSSRC, 4) &&
           verifier.EndTable();
  }
};

struct EncodingMappingBuilder {
  typedef EncodingMapping Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_rid(::flatbuffers::Offset<::flatbuffers::String> rid) {
    fbb_.AddOffset(EncodingMapping::VT_RID, rid);
  }
  void add_ssrc(uint32_t ssrc) {
    fbb_.AddElement<uint32_t>(EncodingMapping::VT_SSRC, ssrc);
  }
  void add_scalabilityMode(::flatbuffers::Offset<::flatbuffers::String> scalabilityMode) {
    fbb_.AddOffset(EncodingMapping::VT_SCALABILITYMODE, scalabilityMode);
  }
  void add_mappedSsrc(uint32_t mappedSsrc) {
    fbb_.AddElement<uint32_t>(EncodingMapping::VT_MAPPEDSSRC, mappedSsrc, 0);
  }
  explicit EncodingMappingBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<EncodingMapping> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<EncodingMapping>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<EncodingMapping> CreateEncodingMapping(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> rid = 0,
    ::flatbuffers::Optional<uint32_t> ssrc = ::flatbuffers::nullopt,
    ::flatbuffers::Offset<::flatbuffers::String> scalabilityMode = 0,
    uint32_t mappedSsrc = 0) {
  EncodingMappingBuilder builder_(_fbb);
  builder_.add_mappedSsrc(mappedSsrc);
  builder_.add_scalabilityMode(scalabilityMode);
  if(ssrc) { builder_.add_ssrc(*ssrc); }
  builder_.add_rid(rid);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<EncodingMapping> CreateEncodingMappingDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *rid = nullptr,
    ::flatbuffers::Optional<uint32_t> ssrc = ::flatbuffers::nullopt,
    const char *scalabilityMode = nullptr,
    uint32_t mappedSsrc = 0) {
  auto rid__ = rid ? _fbb.CreateString(rid) : 0;
  auto scalabilityMode__ = scalabilityMode ? _fbb.CreateString(scalabilityMode) : 0;
  return FBS::RtpParameters::CreateEncodingMapping(
      _fbb,
      rid__,
      ssrc,
      scalabilityMode__,
      mappedSsrc);
}

struct RtpMapping FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RtpMappingBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return RtpMappingTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CODECS = 4,
    VT_ENCODINGS = 6
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<FBS::RtpParameters::CodecMapping>> *codecs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<FBS::RtpParameters::CodecMapping>> *>(VT_CODECS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<FBS::RtpParameters::EncodingMapping>> *encodings() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<FBS::RtpParameters::EncodingMapping>> *>(VT_ENCODINGS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_CODECS) &&
           verifier.VerifyVector(codecs()) &&
           verifier.VerifyVectorOfTables(codecs()) &&
           VerifyOffsetRequired(verifier, VT_ENCODINGS) &&
           verifier.VerifyVector(encodings()) &&
           verifier.VerifyVectorOfTables(encodings()) &&
           verifier.EndTable();
  }
};

struct RtpMappingBuilder {
  typedef RtpMapping Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_codecs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<FBS::RtpParameters::CodecMapping>>> codecs) {
    fbb_.AddOffset(RtpMapping::VT_CODECS, codecs);
  }
  void add_encodings(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<FBS::RtpParameters::EncodingMapping>>> encodings) {
    fbb_.AddOffset(RtpMapping::VT_ENCODINGS, encodings);
  }
  explicit RtpMappingBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RtpMapping> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RtpMapping>(end);
    fbb_.Required(o, RtpMapping::VT_CODECS);
    fbb_.Required(o, RtpMapping::VT_ENCODINGS);
    return o;
  }
};

inline ::flatbuffers::Offset<RtpMapping> CreateRtpMapping(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<FBS::RtpParameters::CodecMapping>>> codecs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<FBS::RtpParameters::EncodingMapping>>> encodings = 0) {
  RtpMappingBuilder builder_(_fbb);
  builder_.add_encodings(encodings);
  builder_.add_codecs(codecs);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<RtpMapping> CreateRtpMappingDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<FBS::RtpParameters::CodecMapping>> *codecs = nullptr,
    const std::vector<::flatbuffers::Offset<FBS::RtpParameters::EncodingMapping>> *encodings = nullptr) {
  auto codecs__ = codecs ? _fbb.CreateVector<::flatbuffers::Offset<FBS::RtpParameters::CodecMapping>>(*codecs) : 0;
  auto encodings__ = encodings ? _fbb.CreateVector<::flatbuffers::Offset<FBS::RtpParameters::EncodingMapping>>(*encodings) : 0;
  return FBS::RtpParameters::CreateRtpMapping(
      _fbb,
      codecs__,
      encodings__);
}

inline bool VerifyValue(::flatbuffers::Verifier &verifier, const void *obj, Value type) {
  switch (type) {
    case Value::NONE: {
      return true;
    }
    case Value::Boolean: {
      auto ptr = reinterpret_cast<const FBS::RtpParameters::Boolean *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Value::Integer32: {
      auto ptr = reinterpret_cast<const FBS::RtpParameters::Integer32 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Value::Double: {
      auto ptr = reinterpret_cast<const FBS::RtpParameters::Double *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Value::String: {
      auto ptr = reinterpret_cast<const FBS::RtpParameters::String *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Value::Integer32Array: {
      auto ptr = reinterpret_cast<const FBS::RtpParameters::Integer32Array *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyValueVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<Value> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyValue(
        verifier,  values->Get(i), types->GetEnum<Value>(i))) {
      return false;
    }
  }
  return true;
}

inline const ::flatbuffers::TypeTable *MediaKindTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_UCHAR, 0, 0 },
    { ::flatbuffers::ET_UCHAR, 0, 0 },
    { ::flatbuffers::ET_UCHAR, 0, 0 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    FBS::RtpParameters::MediaKindTypeTable
  };
  static const char * const names[] = {
    "ALL",
    "AUDIO",
    "VIDEO"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_ENUM, 3, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *TypeTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_UCHAR, 0, 0 },
    { ::flatbuffers::ET_UCHAR, 0, 0 },
    { ::flatbuffers::ET_UCHAR, 0, 0 },
    { ::flatbuffers::ET_UCHAR, 0, 0 },
    { ::flatbuffers::ET_UCHAR, 0, 0 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    FBS::RtpParameters::TypeTypeTable
  };
  static const char * const names[] = {
    "NONE",
    "SIMPLE",
    "SIMULCAST",
    "SVC",
    "PIPE"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_ENUM, 5, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *ValueTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_SEQUENCE, 0, -1 },
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_SEQUENCE, 0, 1 },
    { ::flatbuffers::ET_SEQUENCE, 0, 2 },
    { ::flatbuffers::ET_SEQUENCE, 0, 3 },
    { ::flatbuffers::ET_SEQUENCE, 0, 4 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    FBS::RtpParameters::BooleanTypeTable,
    FBS::RtpParameters::Integer32TypeTable,
    FBS::RtpParameters::DoubleTypeTable,
    FBS::RtpParameters::StringTypeTable,
    FBS::RtpParameters::Integer32ArrayTypeTable
  };
  static const char * const names[] = {
    "NONE",
    "Boolean",
    "Integer32",
    "Double",
    "String",
    "Integer32Array"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_UNION, 6, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *BooleanTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_UCHAR, 0, -1 }
  };
  static const char * const names[] = {
    "value"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *Integer32TypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_INT, 0, -1 }
  };
  static const char * const names[] = {
    "value"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *Integer32ArrayTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_INT, 1, -1 }
  };
  static const char * const names[] = {
    "value"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *DoubleTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_DOUBLE, 0, -1 }
  };
  static const char * const names[] = {
    "value"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *StringTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_STRING, 0, -1 }
  };
  static const char * const names[] = {
    "value"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *ParameterTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_UTYPE, 0, 0 },
    { ::flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    FBS::RtpParameters::ValueTypeTable
  };
  static const char * const names[] = {
    "name",
    "value_type",
    "value"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *RtcpFeedbackTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_STRING, 0, -1 }
  };
  static const char * const names[] = {
    "type",
    "parameter"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *RtpCodecParametersTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_UCHAR, 0, -1 },
    { ::flatbuffers::ET_UINT, 0, -1 },
    { ::flatbuffers::ET_UCHAR, 0, -1 },
    { ::flatbuffers::ET_SEQUENCE, 1, 0 },
    { ::flatbuffers::ET_SEQUENCE, 1, 1 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    FBS::RtpParameters::ParameterTypeTable,
    FBS::RtpParameters::RtcpFeedbackTypeTable
  };
  static const char * const names[] = {
    "mimeType",
    "payloadType",
    "clockRate",
    "channels",
    "parameters",
    "rtcpFeedback"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 6, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *RtpHeaderExtensionParametersTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_UCHAR, 0, -1 },
    { ::flatbuffers::ET_BOOL, 0, -1 },
    { ::flatbuffers::ET_SEQUENCE, 1, 0 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    FBS::RtpParameters::ParameterTypeTable
  };
  static const char * const names[] = {
    "uri",
    "id",
    "encrypt",
    "parameters"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 4, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *RtxTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_UINT, 0, -1 }
  };
  static const char * const names[] = {
    "ssrc"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *RtpEncodingParametersTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_UINT, 0, -1 },
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_UCHAR, 0, -1 },
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_BOOL, 0, -1 },
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_UINT, 0, -1 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    FBS::RtpParameters::RtxTypeTable
  };
  static const char * const names[] = {
    "ssrc",
    "rid",
    "codecPayloadType",
    "rtx",
    "dtx",
    "scalabilityMode",
    "maxBitrate"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 7, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *RtcpParametersTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_BOOL, 0, -1 }
  };
  static const char * const names[] = {
    "cname",
    "reducedSize"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *RtpParametersTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_SEQUENCE, 1, 0 },
    { ::flatbuffers::ET_SEQUENCE, 1, 1 },
    { ::flatbuffers::ET_SEQUENCE, 1, 2 },
    { ::flatbuffers::ET_SEQUENCE, 0, 3 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    FBS::RtpParameters::RtpCodecParametersTypeTable,
    FBS::RtpParameters::RtpHeaderExtensionParametersTypeTable,
    FBS::RtpParameters::RtpEncodingParametersTypeTable,
    FBS::RtpParameters::RtcpParametersTypeTable
  };
  static const char * const names[] = {
    "mid",
    "codecs",
    "headerExtensions",
    "encodings",
    "rtcp"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 5, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *CodecMappingTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_UCHAR, 0, -1 },
    { ::flatbuffers::ET_UCHAR, 0, -1 }
  };
  static const char * const names[] = {
    "payloadType",
    "mappedPayloadType"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *EncodingMappingTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_UINT, 0, -1 },
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_UINT, 0, -1 }
  };
  static const char * const names[] = {
    "rid",
    "ssrc",
    "scalabilityMode",
    "mappedSsrc"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 4, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *RtpMappingTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_SEQUENCE, 1, 0 },
    { ::flatbuffers::ET_SEQUENCE, 1, 1 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    FBS::RtpParameters::CodecMappingTypeTable,
    FBS::RtpParameters::EncodingMappingTypeTable
  };
  static const char * const names[] = {
    "codecs",
    "encodings"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

}  // namespace RtpParameters
}  // namespace FBS

#endif  // FLATBUFFERS_GENERATED_RTPPARAMETERS_FBS_RTPPARAMETERS_H_
