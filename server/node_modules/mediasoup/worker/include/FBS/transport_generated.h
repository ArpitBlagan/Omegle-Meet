// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_TRANSPORT_FBS_TRANSPORT_H_
#define FLATBUFFERS_GENERATED_TRANSPORT_FBS_TRANSPORT_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 3,
             "Non-compatible flatbuffers version included");

#include "common_generated.h"
#include "consumer_generated.h"
#include "rtpParameters_generated.h"
#include "sctpAssociation_generated.h"
#include "sctpParameters_generated.h"

namespace FBS {
namespace Transport {

struct ListenInfo;
struct ListenInfoBuilder;

struct RestartIceResponse;
struct RestartIceResponseBuilder;

struct ProduceRequest;
struct ProduceRequestBuilder;

struct ProduceResponse;
struct ProduceResponseBuilder;

struct ConsumeRequest;
struct ConsumeRequestBuilder;

struct ConsumeResponse;
struct ConsumeResponseBuilder;

struct ProduceDataRequest;
struct ProduceDataRequestBuilder;

struct ConsumeDataRequest;
struct ConsumeDataRequestBuilder;

struct Tuple;
struct TupleBuilder;

struct SrtpParameters;
struct SrtpParametersBuilder;

struct RtpListener;
struct RtpListenerBuilder;

struct SctpListener;
struct SctpListenerBuilder;

struct RecvRtpHeaderExtensions;
struct RecvRtpHeaderExtensionsBuilder;

struct Options;
struct OptionsBuilder;

struct Dump;
struct DumpBuilder;

struct Stats;
struct StatsBuilder;

struct SetMaxIncomingBitrateRequest;
struct SetMaxIncomingBitrateRequestBuilder;

struct SetMaxOutgoingBitrateRequest;
struct SetMaxOutgoingBitrateRequestBuilder;

struct SetMinOutgoingBitrateRequest;
struct SetMinOutgoingBitrateRequestBuilder;

struct EnableTraceEventRequest;
struct EnableTraceEventRequestBuilder;

struct CloseProducerRequest;
struct CloseProducerRequestBuilder;

struct CloseConsumerRequest;
struct CloseConsumerRequestBuilder;

struct CloseDataProducerRequest;
struct CloseDataProducerRequestBuilder;

struct CloseDataConsumerRequest;
struct CloseDataConsumerRequestBuilder;

struct SendRtcpNotification;
struct SendRtcpNotificationBuilder;

struct SctpStateChangeNotification;
struct SctpStateChangeNotificationBuilder;

struct BweTraceInfo;
struct BweTraceInfoBuilder;

struct TraceNotification;
struct TraceNotificationBuilder;

inline const ::flatbuffers::TypeTable *ListenInfoTypeTable();

inline const ::flatbuffers::TypeTable *RestartIceResponseTypeTable();

inline const ::flatbuffers::TypeTable *ProduceRequestTypeTable();

inline const ::flatbuffers::TypeTable *ProduceResponseTypeTable();

inline const ::flatbuffers::TypeTable *ConsumeRequestTypeTable();

inline const ::flatbuffers::TypeTable *ConsumeResponseTypeTable();

inline const ::flatbuffers::TypeTable *ProduceDataRequestTypeTable();

inline const ::flatbuffers::TypeTable *ConsumeDataRequestTypeTable();

inline const ::flatbuffers::TypeTable *TupleTypeTable();

inline const ::flatbuffers::TypeTable *SrtpParametersTypeTable();

inline const ::flatbuffers::TypeTable *RtpListenerTypeTable();

inline const ::flatbuffers::TypeTable *SctpListenerTypeTable();

inline const ::flatbuffers::TypeTable *RecvRtpHeaderExtensionsTypeTable();

inline const ::flatbuffers::TypeTable *OptionsTypeTable();

inline const ::flatbuffers::TypeTable *DumpTypeTable();

inline const ::flatbuffers::TypeTable *StatsTypeTable();

inline const ::flatbuffers::TypeTable *SetMaxIncomingBitrateRequestTypeTable();

inline const ::flatbuffers::TypeTable *SetMaxOutgoingBitrateRequestTypeTable();

inline const ::flatbuffers::TypeTable *SetMinOutgoingBitrateRequestTypeTable();

inline const ::flatbuffers::TypeTable *EnableTraceEventRequestTypeTable();

inline const ::flatbuffers::TypeTable *CloseProducerRequestTypeTable();

inline const ::flatbuffers::TypeTable *CloseConsumerRequestTypeTable();

inline const ::flatbuffers::TypeTable *CloseDataProducerRequestTypeTable();

inline const ::flatbuffers::TypeTable *CloseDataConsumerRequestTypeTable();

inline const ::flatbuffers::TypeTable *SendRtcpNotificationTypeTable();

inline const ::flatbuffers::TypeTable *SctpStateChangeNotificationTypeTable();

inline const ::flatbuffers::TypeTable *BweTraceInfoTypeTable();

inline const ::flatbuffers::TypeTable *TraceNotificationTypeTable();

enum class Protocol : uint8_t {
  UDP = 1,
  TCP = 2,
  MIN = UDP,
  MAX = TCP
};

inline const Protocol (&EnumValuesProtocol())[2] {
  static const Protocol values[] = {
    Protocol::UDP,
    Protocol::TCP
  };
  return values;
}

inline const char * const *EnumNamesProtocol() {
  static const char * const names[3] = {
    "UDP",
    "TCP",
    nullptr
  };
  return names;
}

inline const char *EnumNameProtocol(Protocol e) {
  if (::flatbuffers::IsOutRange(e, Protocol::UDP, Protocol::TCP)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(Protocol::UDP);
  return EnumNamesProtocol()[index];
}

enum class TraceType : uint8_t {
  PROBATION = 0,
  BWE = 1,
  MIN = PROBATION,
  MAX = BWE
};

inline const TraceType (&EnumValuesTraceType())[2] {
  static const TraceType values[] = {
    TraceType::PROBATION,
    TraceType::BWE
  };
  return values;
}

inline const char * const *EnumNamesTraceType() {
  static const char * const names[3] = {
    "PROBATION",
    "BWE",
    nullptr
  };
  return names;
}

inline const char *EnumNameTraceType(TraceType e) {
  if (::flatbuffers::IsOutRange(e, TraceType::PROBATION, TraceType::BWE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTraceType()[index];
}

enum class TraceDirection : uint8_t {
  DIRECTION_IN = 0,
  DIRECTION_OUT = 1,
  MIN = DIRECTION_IN,
  MAX = DIRECTION_OUT
};

inline const TraceDirection (&EnumValuesTraceDirection())[2] {
  static const TraceDirection values[] = {
    TraceDirection::DIRECTION_IN,
    TraceDirection::DIRECTION_OUT
  };
  return values;
}

inline const char * const *EnumNamesTraceDirection() {
  static const char * const names[3] = {
    "DIRECTION_IN",
    "DIRECTION_OUT",
    nullptr
  };
  return names;
}

inline const char *EnumNameTraceDirection(TraceDirection e) {
  if (::flatbuffers::IsOutRange(e, TraceDirection::DIRECTION_IN, TraceDirection::DIRECTION_OUT)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTraceDirection()[index];
}

enum class TraceInfo : uint8_t {
  NONE = 0,
  BweTraceInfo = 1,
  MIN = NONE,
  MAX = BweTraceInfo
};

inline const TraceInfo (&EnumValuesTraceInfo())[2] {
  static const TraceInfo values[] = {
    TraceInfo::NONE,
    TraceInfo::BweTraceInfo
  };
  return values;
}

inline const char * const *EnumNamesTraceInfo() {
  static const char * const names[3] = {
    "NONE",
    "BweTraceInfo",
    nullptr
  };
  return names;
}

inline const char *EnumNameTraceInfo(TraceInfo e) {
  if (::flatbuffers::IsOutRange(e, TraceInfo::NONE, TraceInfo::BweTraceInfo)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTraceInfo()[index];
}

template<typename T> struct TraceInfoTraits {
  static const TraceInfo enum_value = TraceInfo::NONE;
};

template<> struct TraceInfoTraits<FBS::Transport::BweTraceInfo> {
  static const TraceInfo enum_value = TraceInfo::BweTraceInfo;
};

bool VerifyTraceInfo(::flatbuffers::Verifier &verifier, const void *obj, TraceInfo type);
bool VerifyTraceInfoVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<TraceInfo> *types);

enum class BweType : uint8_t {
  TRANSPORT_CC = 0,
  REMB = 1,
  MIN = TRANSPORT_CC,
  MAX = REMB
};

inline const BweType (&EnumValuesBweType())[2] {
  static const BweType values[] = {
    BweType::TRANSPORT_CC,
    BweType::REMB
  };
  return values;
}

inline const char * const *EnumNamesBweType() {
  static const char * const names[3] = {
    "TRANSPORT_CC",
    "REMB",
    nullptr
  };
  return names;
}

inline const char *EnumNameBweType(BweType e) {
  if (::flatbuffers::IsOutRange(e, BweType::TRANSPORT_CC, BweType::REMB)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesBweType()[index];
}

struct ListenInfo FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ListenInfoBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ListenInfoTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PROTOCOL = 4,
    VT_IP = 6,
    VT_ANNOUNCEDIP = 8,
    VT_PORT = 10,
    VT_SENDBUFFERSIZE = 12,
    VT_RECVBUFFERSIZE = 14
  };
  FBS::Transport::Protocol protocol() const {
    return static_cast<FBS::Transport::Protocol>(GetField<uint8_t>(VT_PROTOCOL, 1));
  }
  const ::flatbuffers::String *ip() const {
    return GetPointer<const ::flatbuffers::String *>(VT_IP);
  }
  const ::flatbuffers::String *announcedIp() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ANNOUNCEDIP);
  }
  uint16_t port() const {
    return GetField<uint16_t>(VT_PORT, 0);
  }
  uint32_t sendBufferSize() const {
    return GetField<uint32_t>(VT_SENDBUFFERSIZE, 0);
  }
  uint32_t recvBufferSize() const {
    return GetField<uint32_t>(VT_RECVBUFFERSIZE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_PROTOCOL, 1) &&
           VerifyOffsetRequired(verifier, VT_IP) &&
           verifier.VerifyString(ip()) &&
           VerifyOffset(verifier, VT_ANNOUNCEDIP) &&
           verifier.VerifyString(announcedIp()) &&
           VerifyField<uint16_t>(verifier, VT_PORT, 2) &&
           VerifyField<uint32_t>(verifier, VT_SENDBUFFERSIZE, 4) &&
           VerifyField<uint32_t>(verifier, VT_RECVBUFFERSIZE, 4) &&
           verifier.EndTable();
  }
};

struct ListenInfoBuilder {
  typedef ListenInfo Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_protocol(FBS::Transport::Protocol protocol) {
    fbb_.AddElement<uint8_t>(ListenInfo::VT_PROTOCOL, static_cast<uint8_t>(protocol), 1);
  }
  void add_ip(::flatbuffers::Offset<::flatbuffers::String> ip) {
    fbb_.AddOffset(ListenInfo::VT_IP, ip);
  }
  void add_announcedIp(::flatbuffers::Offset<::flatbuffers::String> announcedIp) {
    fbb_.AddOffset(ListenInfo::VT_ANNOUNCEDIP, announcedIp);
  }
  void add_port(uint16_t port) {
    fbb_.AddElement<uint16_t>(ListenInfo::VT_PORT, port, 0);
  }
  void add_sendBufferSize(uint32_t sendBufferSize) {
    fbb_.AddElement<uint32_t>(ListenInfo::VT_SENDBUFFERSIZE, sendBufferSize, 0);
  }
  void add_recvBufferSize(uint32_t recvBufferSize) {
    fbb_.AddElement<uint32_t>(ListenInfo::VT_RECVBUFFERSIZE, recvBufferSize, 0);
  }
  explicit ListenInfoBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ListenInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ListenInfo>(end);
    fbb_.Required(o, ListenInfo::VT_IP);
    return o;
  }
};

inline ::flatbuffers::Offset<ListenInfo> CreateListenInfo(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    FBS::Transport::Protocol protocol = FBS::Transport::Protocol::UDP,
    ::flatbuffers::Offset<::flatbuffers::String> ip = 0,
    ::flatbuffers::Offset<::flatbuffers::String> announcedIp = 0,
    uint16_t port = 0,
    uint32_t sendBufferSize = 0,
    uint32_t recvBufferSize = 0) {
  ListenInfoBuilder builder_(_fbb);
  builder_.add_recvBufferSize(recvBufferSize);
  builder_.add_sendBufferSize(sendBufferSize);
  builder_.add_announcedIp(announcedIp);
  builder_.add_ip(ip);
  builder_.add_port(port);
  builder_.add_protocol(protocol);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ListenInfo> CreateListenInfoDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    FBS::Transport::Protocol protocol = FBS::Transport::Protocol::UDP,
    const char *ip = nullptr,
    const char *announcedIp = nullptr,
    uint16_t port = 0,
    uint32_t sendBufferSize = 0,
    uint32_t recvBufferSize = 0) {
  auto ip__ = ip ? _fbb.CreateString(ip) : 0;
  auto announcedIp__ = announcedIp ? _fbb.CreateString(announcedIp) : 0;
  return FBS::Transport::CreateListenInfo(
      _fbb,
      protocol,
      ip__,
      announcedIp__,
      port,
      sendBufferSize,
      recvBufferSize);
}

struct RestartIceResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RestartIceResponseBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return RestartIceResponseTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_USERNAMEFRAGMENT = 4,
    VT_PASSWORD = 6,
    VT_ICELITE = 8
  };
  const ::flatbuffers::String *usernameFragment() const {
    return GetPointer<const ::flatbuffers::String *>(VT_USERNAMEFRAGMENT);
  }
  const ::flatbuffers::String *password() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PASSWORD);
  }
  bool iceLite() const {
    return GetField<uint8_t>(VT_ICELITE, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_USERNAMEFRAGMENT) &&
           verifier.VerifyString(usernameFragment()) &&
           VerifyOffsetRequired(verifier, VT_PASSWORD) &&
           verifier.VerifyString(password()) &&
           VerifyField<uint8_t>(verifier, VT_ICELITE, 1) &&
           verifier.EndTable();
  }
};

struct RestartIceResponseBuilder {
  typedef RestartIceResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_usernameFragment(::flatbuffers::Offset<::flatbuffers::String> usernameFragment) {
    fbb_.AddOffset(RestartIceResponse::VT_USERNAMEFRAGMENT, usernameFragment);
  }
  void add_password(::flatbuffers::Offset<::flatbuffers::String> password) {
    fbb_.AddOffset(RestartIceResponse::VT_PASSWORD, password);
  }
  void add_iceLite(bool iceLite) {
    fbb_.AddElement<uint8_t>(RestartIceResponse::VT_ICELITE, static_cast<uint8_t>(iceLite), 0);
  }
  explicit RestartIceResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RestartIceResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RestartIceResponse>(end);
    fbb_.Required(o, RestartIceResponse::VT_USERNAMEFRAGMENT);
    fbb_.Required(o, RestartIceResponse::VT_PASSWORD);
    return o;
  }
};

inline ::flatbuffers::Offset<RestartIceResponse> CreateRestartIceResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> usernameFragment = 0,
    ::flatbuffers::Offset<::flatbuffers::String> password = 0,
    bool iceLite = false) {
  RestartIceResponseBuilder builder_(_fbb);
  builder_.add_password(password);
  builder_.add_usernameFragment(usernameFragment);
  builder_.add_iceLite(iceLite);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<RestartIceResponse> CreateRestartIceResponseDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *usernameFragment = nullptr,
    const char *password = nullptr,
    bool iceLite = false) {
  auto usernameFragment__ = usernameFragment ? _fbb.CreateString(usernameFragment) : 0;
  auto password__ = password ? _fbb.CreateString(password) : 0;
  return FBS::Transport::CreateRestartIceResponse(
      _fbb,
      usernameFragment__,
      password__,
      iceLite);
}

struct ProduceRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ProduceRequestBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ProduceRequestTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PRODUCERID = 4,
    VT_KIND = 6,
    VT_RTPPARAMETERS = 8,
    VT_RTPMAPPING = 10,
    VT_KEYFRAMEREQUESTDELAY = 12,
    VT_PAUSED = 14
  };
  const ::flatbuffers::String *producerId() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PRODUCERID);
  }
  FBS::RtpParameters::MediaKind kind() const {
    return static_cast<FBS::RtpParameters::MediaKind>(GetField<uint8_t>(VT_KIND, 0));
  }
  const FBS::RtpParameters::RtpParameters *rtpParameters() const {
    return GetPointer<const FBS::RtpParameters::RtpParameters *>(VT_RTPPARAMETERS);
  }
  const FBS::RtpParameters::RtpMapping *rtpMapping() const {
    return GetPointer<const FBS::RtpParameters::RtpMapping *>(VT_RTPMAPPING);
  }
  uint16_t keyFrameRequestDelay() const {
    return GetField<uint16_t>(VT_KEYFRAMEREQUESTDELAY, 0);
  }
  bool paused() const {
    return GetField<uint8_t>(VT_PAUSED, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_PRODUCERID) &&
           verifier.VerifyString(producerId()) &&
           VerifyField<uint8_t>(verifier, VT_KIND, 1) &&
           VerifyOffsetRequired(verifier, VT_RTPPARAMETERS) &&
           verifier.VerifyTable(rtpParameters()) &&
           VerifyOffsetRequired(verifier, VT_RTPMAPPING) &&
           verifier.VerifyTable(rtpMapping()) &&
           VerifyField<uint16_t>(verifier, VT_KEYFRAMEREQUESTDELAY, 2) &&
           VerifyField<uint8_t>(verifier, VT_PAUSED, 1) &&
           verifier.EndTable();
  }
};

struct ProduceRequestBuilder {
  typedef ProduceRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_producerId(::flatbuffers::Offset<::flatbuffers::String> producerId) {
    fbb_.AddOffset(ProduceRequest::VT_PRODUCERID, producerId);
  }
  void add_kind(FBS::RtpParameters::MediaKind kind) {
    fbb_.AddElement<uint8_t>(ProduceRequest::VT_KIND, static_cast<uint8_t>(kind), 0);
  }
  void add_rtpParameters(::flatbuffers::Offset<FBS::RtpParameters::RtpParameters> rtpParameters) {
    fbb_.AddOffset(ProduceRequest::VT_RTPPARAMETERS, rtpParameters);
  }
  void add_rtpMapping(::flatbuffers::Offset<FBS::RtpParameters::RtpMapping> rtpMapping) {
    fbb_.AddOffset(ProduceRequest::VT_RTPMAPPING, rtpMapping);
  }
  void add_keyFrameRequestDelay(uint16_t keyFrameRequestDelay) {
    fbb_.AddElement<uint16_t>(ProduceRequest::VT_KEYFRAMEREQUESTDELAY, keyFrameRequestDelay, 0);
  }
  void add_paused(bool paused) {
    fbb_.AddElement<uint8_t>(ProduceRequest::VT_PAUSED, static_cast<uint8_t>(paused), 0);
  }
  explicit ProduceRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ProduceRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ProduceRequest>(end);
    fbb_.Required(o, ProduceRequest::VT_PRODUCERID);
    fbb_.Required(o, ProduceRequest::VT_RTPPARAMETERS);
    fbb_.Required(o, ProduceRequest::VT_RTPMAPPING);
    return o;
  }
};

inline ::flatbuffers::Offset<ProduceRequest> CreateProduceRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> producerId = 0,
    FBS::RtpParameters::MediaKind kind = FBS::RtpParameters::MediaKind::ALL,
    ::flatbuffers::Offset<FBS::RtpParameters::RtpParameters> rtpParameters = 0,
    ::flatbuffers::Offset<FBS::RtpParameters::RtpMapping> rtpMapping = 0,
    uint16_t keyFrameRequestDelay = 0,
    bool paused = false) {
  ProduceRequestBuilder builder_(_fbb);
  builder_.add_rtpMapping(rtpMapping);
  builder_.add_rtpParameters(rtpParameters);
  builder_.add_producerId(producerId);
  builder_.add_keyFrameRequestDelay(keyFrameRequestDelay);
  builder_.add_paused(paused);
  builder_.add_kind(kind);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ProduceRequest> CreateProduceRequestDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *producerId = nullptr,
    FBS::RtpParameters::MediaKind kind = FBS::RtpParameters::MediaKind::ALL,
    ::flatbuffers::Offset<FBS::RtpParameters::RtpParameters> rtpParameters = 0,
    ::flatbuffers::Offset<FBS::RtpParameters::RtpMapping> rtpMapping = 0,
    uint16_t keyFrameRequestDelay = 0,
    bool paused = false) {
  auto producerId__ = producerId ? _fbb.CreateString(producerId) : 0;
  return FBS::Transport::CreateProduceRequest(
      _fbb,
      producerId__,
      kind,
      rtpParameters,
      rtpMapping,
      keyFrameRequestDelay,
      paused);
}

struct ProduceResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ProduceResponseBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ProduceResponseTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4
  };
  FBS::RtpParameters::Type type() const {
    return static_cast<FBS::RtpParameters::Type>(GetField<uint8_t>(VT_TYPE, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_TYPE, 1) &&
           verifier.EndTable();
  }
};

struct ProduceResponseBuilder {
  typedef ProduceResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_type(FBS::RtpParameters::Type type) {
    fbb_.AddElement<uint8_t>(ProduceResponse::VT_TYPE, static_cast<uint8_t>(type), 0);
  }
  explicit ProduceResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ProduceResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ProduceResponse>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ProduceResponse> CreateProduceResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    FBS::RtpParameters::Type type = FBS::RtpParameters::Type::NONE) {
  ProduceResponseBuilder builder_(_fbb);
  builder_.add_type(type);
  return builder_.Finish();
}

struct ConsumeRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ConsumeRequestBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ConsumeRequestTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CONSUMERID = 4,
    VT_PRODUCERID = 6,
    VT_KIND = 8,
    VT_RTPPARAMETERS = 10,
    VT_TYPE = 12,
    VT_CONSUMABLERTPENCODINGS = 14,
    VT_PAUSED = 16,
    VT_PREFERREDLAYERS = 18,
    VT_IGNOREDTX = 20
  };
  const ::flatbuffers::String *consumerId() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CONSUMERID);
  }
  const ::flatbuffers::String *producerId() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PRODUCERID);
  }
  FBS::RtpParameters::MediaKind kind() const {
    return static_cast<FBS::RtpParameters::MediaKind>(GetField<uint8_t>(VT_KIND, 0));
  }
  const FBS::RtpParameters::RtpParameters *rtpParameters() const {
    return GetPointer<const FBS::RtpParameters::RtpParameters *>(VT_RTPPARAMETERS);
  }
  FBS::RtpParameters::Type type() const {
    return static_cast<FBS::RtpParameters::Type>(GetField<uint8_t>(VT_TYPE, 0));
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<FBS::RtpParameters::RtpEncodingParameters>> *consumableRtpEncodings() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<FBS::RtpParameters::RtpEncodingParameters>> *>(VT_CONSUMABLERTPENCODINGS);
  }
  bool paused() const {
    return GetField<uint8_t>(VT_PAUSED, 0) != 0;
  }
  const FBS::Consumer::ConsumerLayers *preferredLayers() const {
    return GetPointer<const FBS::Consumer::ConsumerLayers *>(VT_PREFERREDLAYERS);
  }
  bool ignoreDtx() const {
    return GetField<uint8_t>(VT_IGNOREDTX, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_CONSUMERID) &&
           verifier.VerifyString(consumerId()) &&
           VerifyOffsetRequired(verifier, VT_PRODUCERID) &&
           verifier.VerifyString(producerId()) &&
           VerifyField<uint8_t>(verifier, VT_KIND, 1) &&
           VerifyOffsetRequired(verifier, VT_RTPPARAMETERS) &&
           verifier.VerifyTable(rtpParameters()) &&
           VerifyField<uint8_t>(verifier, VT_TYPE, 1) &&
           VerifyOffsetRequired(verifier, VT_CONSUMABLERTPENCODINGS) &&
           verifier.VerifyVector(consumableRtpEncodings()) &&
           verifier.VerifyVectorOfTables(consumableRtpEncodings()) &&
           VerifyField<uint8_t>(verifier, VT_PAUSED, 1) &&
           VerifyOffset(verifier, VT_PREFERREDLAYERS) &&
           verifier.VerifyTable(preferredLayers()) &&
           VerifyField<uint8_t>(verifier, VT_IGNOREDTX, 1) &&
           verifier.EndTable();
  }
};

struct ConsumeRequestBuilder {
  typedef ConsumeRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_consumerId(::flatbuffers::Offset<::flatbuffers::String> consumerId) {
    fbb_.AddOffset(ConsumeRequest::VT_CONSUMERID, consumerId);
  }
  void add_producerId(::flatbuffers::Offset<::flatbuffers::String> producerId) {
    fbb_.AddOffset(ConsumeRequest::VT_PRODUCERID, producerId);
  }
  void add_kind(FBS::RtpParameters::MediaKind kind) {
    fbb_.AddElement<uint8_t>(ConsumeRequest::VT_KIND, static_cast<uint8_t>(kind), 0);
  }
  void add_rtpParameters(::flatbuffers::Offset<FBS::RtpParameters::RtpParameters> rtpParameters) {
    fbb_.AddOffset(ConsumeRequest::VT_RTPPARAMETERS, rtpParameters);
  }
  void add_type(FBS::RtpParameters::Type type) {
    fbb_.AddElement<uint8_t>(ConsumeRequest::VT_TYPE, static_cast<uint8_t>(type), 0);
  }
  void add_consumableRtpEncodings(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<FBS::RtpParameters::RtpEncodingParameters>>> consumableRtpEncodings) {
    fbb_.AddOffset(ConsumeRequest::VT_CONSUMABLERTPENCODINGS, consumableRtpEncodings);
  }
  void add_paused(bool paused) {
    fbb_.AddElement<uint8_t>(ConsumeRequest::VT_PAUSED, static_cast<uint8_t>(paused), 0);
  }
  void add_preferredLayers(::flatbuffers::Offset<FBS::Consumer::ConsumerLayers> preferredLayers) {
    fbb_.AddOffset(ConsumeRequest::VT_PREFERREDLAYERS, preferredLayers);
  }
  void add_ignoreDtx(bool ignoreDtx) {
    fbb_.AddElement<uint8_t>(ConsumeRequest::VT_IGNOREDTX, static_cast<uint8_t>(ignoreDtx), 0);
  }
  explicit ConsumeRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ConsumeRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ConsumeRequest>(end);
    fbb_.Required(o, ConsumeRequest::VT_CONSUMERID);
    fbb_.Required(o, ConsumeRequest::VT_PRODUCERID);
    fbb_.Required(o, ConsumeRequest::VT_RTPPARAMETERS);
    fbb_.Required(o, ConsumeRequest::VT_CONSUMABLERTPENCODINGS);
    return o;
  }
};

inline ::flatbuffers::Offset<ConsumeRequest> CreateConsumeRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> consumerId = 0,
    ::flatbuffers::Offset<::flatbuffers::String> producerId = 0,
    FBS::RtpParameters::MediaKind kind = FBS::RtpParameters::MediaKind::ALL,
    ::flatbuffers::Offset<FBS::RtpParameters::RtpParameters> rtpParameters = 0,
    FBS::RtpParameters::Type type = FBS::RtpParameters::Type::NONE,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<FBS::RtpParameters::RtpEncodingParameters>>> consumableRtpEncodings = 0,
    bool paused = false,
    ::flatbuffers::Offset<FBS::Consumer::ConsumerLayers> preferredLayers = 0,
    bool ignoreDtx = false) {
  ConsumeRequestBuilder builder_(_fbb);
  builder_.add_preferredLayers(preferredLayers);
  builder_.add_consumableRtpEncodings(consumableRtpEncodings);
  builder_.add_rtpParameters(rtpParameters);
  builder_.add_producerId(producerId);
  builder_.add_consumerId(consumerId);
  builder_.add_ignoreDtx(ignoreDtx);
  builder_.add_paused(paused);
  builder_.add_type(type);
  builder_.add_kind(kind);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ConsumeRequest> CreateConsumeRequestDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *consumerId = nullptr,
    const char *producerId = nullptr,
    FBS::RtpParameters::MediaKind kind = FBS::RtpParameters::MediaKind::ALL,
    ::flatbuffers::Offset<FBS::RtpParameters::RtpParameters> rtpParameters = 0,
    FBS::RtpParameters::Type type = FBS::RtpParameters::Type::NONE,
    const std::vector<::flatbuffers::Offset<FBS::RtpParameters::RtpEncodingParameters>> *consumableRtpEncodings = nullptr,
    bool paused = false,
    ::flatbuffers::Offset<FBS::Consumer::ConsumerLayers> preferredLayers = 0,
    bool ignoreDtx = false) {
  auto consumerId__ = consumerId ? _fbb.CreateString(consumerId) : 0;
  auto producerId__ = producerId ? _fbb.CreateString(producerId) : 0;
  auto consumableRtpEncodings__ = consumableRtpEncodings ? _fbb.CreateVector<::flatbuffers::Offset<FBS::RtpParameters::RtpEncodingParameters>>(*consumableRtpEncodings) : 0;
  return FBS::Transport::CreateConsumeRequest(
      _fbb,
      consumerId__,
      producerId__,
      kind,
      rtpParameters,
      type,
      consumableRtpEncodings__,
      paused,
      preferredLayers,
      ignoreDtx);
}

struct ConsumeResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ConsumeResponseBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ConsumeResponseTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PAUSED = 4,
    VT_PRODUCERPAUSED = 6,
    VT_SCORE = 8,
    VT_PREFERREDLAYERS = 10
  };
  bool paused() const {
    return GetField<uint8_t>(VT_PAUSED, 0) != 0;
  }
  bool producerPaused() const {
    return GetField<uint8_t>(VT_PRODUCERPAUSED, 0) != 0;
  }
  const FBS::Consumer::ConsumerScore *score() const {
    return GetPointer<const FBS::Consumer::ConsumerScore *>(VT_SCORE);
  }
  const FBS::Consumer::ConsumerLayers *preferredLayers() const {
    return GetPointer<const FBS::Consumer::ConsumerLayers *>(VT_PREFERREDLAYERS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_PAUSED, 1) &&
           VerifyField<uint8_t>(verifier, VT_PRODUCERPAUSED, 1) &&
           VerifyOffset(verifier, VT_SCORE) &&
           verifier.VerifyTable(score()) &&
           VerifyOffset(verifier, VT_PREFERREDLAYERS) &&
           verifier.VerifyTable(preferredLayers()) &&
           verifier.EndTable();
  }
};

struct ConsumeResponseBuilder {
  typedef ConsumeResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_paused(bool paused) {
    fbb_.AddElement<uint8_t>(ConsumeResponse::VT_PAUSED, static_cast<uint8_t>(paused), 0);
  }
  void add_producerPaused(bool producerPaused) {
    fbb_.AddElement<uint8_t>(ConsumeResponse::VT_PRODUCERPAUSED, static_cast<uint8_t>(producerPaused), 0);
  }
  void add_score(::flatbuffers::Offset<FBS::Consumer::ConsumerScore> score) {
    fbb_.AddOffset(ConsumeResponse::VT_SCORE, score);
  }
  void add_preferredLayers(::flatbuffers::Offset<FBS::Consumer::ConsumerLayers> preferredLayers) {
    fbb_.AddOffset(ConsumeResponse::VT_PREFERREDLAYERS, preferredLayers);
  }
  explicit ConsumeResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ConsumeResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ConsumeResponse>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ConsumeResponse> CreateConsumeResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool paused = false,
    bool producerPaused = false,
    ::flatbuffers::Offset<FBS::Consumer::ConsumerScore> score = 0,
    ::flatbuffers::Offset<FBS::Consumer::ConsumerLayers> preferredLayers = 0) {
  ConsumeResponseBuilder builder_(_fbb);
  builder_.add_preferredLayers(preferredLayers);
  builder_.add_score(score);
  builder_.add_producerPaused(producerPaused);
  builder_.add_paused(paused);
  return builder_.Finish();
}

struct ProduceDataRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ProduceDataRequestBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ProduceDataRequestTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATAPRODUCERID = 4,
    VT_TYPE = 6,
    VT_SCTPSTREAMPARAMETERS = 8,
    VT_LABEL = 10,
    VT_PROTOCOL = 12,
    VT_PAUSED = 14
  };
  const ::flatbuffers::String *dataProducerId() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DATAPRODUCERID);
  }
  const ::flatbuffers::String *type() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TYPE);
  }
  const FBS::SctpParameters::SctpStreamParameters *sctpStreamParameters() const {
    return GetPointer<const FBS::SctpParameters::SctpStreamParameters *>(VT_SCTPSTREAMPARAMETERS);
  }
  const ::flatbuffers::String *label() const {
    return GetPointer<const ::flatbuffers::String *>(VT_LABEL);
  }
  const ::flatbuffers::String *protocol() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PROTOCOL);
  }
  bool paused() const {
    return GetField<uint8_t>(VT_PAUSED, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_DATAPRODUCERID) &&
           verifier.VerifyString(dataProducerId()) &&
           VerifyOffsetRequired(verifier, VT_TYPE) &&
           verifier.VerifyString(type()) &&
           VerifyOffset(verifier, VT_SCTPSTREAMPARAMETERS) &&
           verifier.VerifyTable(sctpStreamParameters()) &&
           VerifyOffset(verifier, VT_LABEL) &&
           verifier.VerifyString(label()) &&
           VerifyOffset(verifier, VT_PROTOCOL) &&
           verifier.VerifyString(protocol()) &&
           VerifyField<uint8_t>(verifier, VT_PAUSED, 1) &&
           verifier.EndTable();
  }
};

struct ProduceDataRequestBuilder {
  typedef ProduceDataRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_dataProducerId(::flatbuffers::Offset<::flatbuffers::String> dataProducerId) {
    fbb_.AddOffset(ProduceDataRequest::VT_DATAPRODUCERID, dataProducerId);
  }
  void add_type(::flatbuffers::Offset<::flatbuffers::String> type) {
    fbb_.AddOffset(ProduceDataRequest::VT_TYPE, type);
  }
  void add_sctpStreamParameters(::flatbuffers::Offset<FBS::SctpParameters::SctpStreamParameters> sctpStreamParameters) {
    fbb_.AddOffset(ProduceDataRequest::VT_SCTPSTREAMPARAMETERS, sctpStreamParameters);
  }
  void add_label(::flatbuffers::Offset<::flatbuffers::String> label) {
    fbb_.AddOffset(ProduceDataRequest::VT_LABEL, label);
  }
  void add_protocol(::flatbuffers::Offset<::flatbuffers::String> protocol) {
    fbb_.AddOffset(ProduceDataRequest::VT_PROTOCOL, protocol);
  }
  void add_paused(bool paused) {
    fbb_.AddElement<uint8_t>(ProduceDataRequest::VT_PAUSED, static_cast<uint8_t>(paused), 0);
  }
  explicit ProduceDataRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ProduceDataRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ProduceDataRequest>(end);
    fbb_.Required(o, ProduceDataRequest::VT_DATAPRODUCERID);
    fbb_.Required(o, ProduceDataRequest::VT_TYPE);
    return o;
  }
};

inline ::flatbuffers::Offset<ProduceDataRequest> CreateProduceDataRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> dataProducerId = 0,
    ::flatbuffers::Offset<::flatbuffers::String> type = 0,
    ::flatbuffers::Offset<FBS::SctpParameters::SctpStreamParameters> sctpStreamParameters = 0,
    ::flatbuffers::Offset<::flatbuffers::String> label = 0,
    ::flatbuffers::Offset<::flatbuffers::String> protocol = 0,
    bool paused = false) {
  ProduceDataRequestBuilder builder_(_fbb);
  builder_.add_protocol(protocol);
  builder_.add_label(label);
  builder_.add_sctpStreamParameters(sctpStreamParameters);
  builder_.add_type(type);
  builder_.add_dataProducerId(dataProducerId);
  builder_.add_paused(paused);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ProduceDataRequest> CreateProduceDataRequestDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *dataProducerId = nullptr,
    const char *type = nullptr,
    ::flatbuffers::Offset<FBS::SctpParameters::SctpStreamParameters> sctpStreamParameters = 0,
    const char *label = nullptr,
    const char *protocol = nullptr,
    bool paused = false) {
  auto dataProducerId__ = dataProducerId ? _fbb.CreateString(dataProducerId) : 0;
  auto type__ = type ? _fbb.CreateString(type) : 0;
  auto label__ = label ? _fbb.CreateString(label) : 0;
  auto protocol__ = protocol ? _fbb.CreateString(protocol) : 0;
  return FBS::Transport::CreateProduceDataRequest(
      _fbb,
      dataProducerId__,
      type__,
      sctpStreamParameters,
      label__,
      protocol__,
      paused);
}

struct ConsumeDataRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ConsumeDataRequestBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ConsumeDataRequestTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATACONSUMERID = 4,
    VT_DATAPRODUCERID = 6,
    VT_TYPE = 8,
    VT_SCTPSTREAMPARAMETERS = 10,
    VT_LABEL = 12,
    VT_PROTOCOL = 14,
    VT_PAUSED = 16,
    VT_SUBCHANNELS = 18
  };
  const ::flatbuffers::String *dataConsumerId() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DATACONSUMERID);
  }
  const ::flatbuffers::String *dataProducerId() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DATAPRODUCERID);
  }
  const ::flatbuffers::String *type() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TYPE);
  }
  const FBS::SctpParameters::SctpStreamParameters *sctpStreamParameters() const {
    return GetPointer<const FBS::SctpParameters::SctpStreamParameters *>(VT_SCTPSTREAMPARAMETERS);
  }
  const ::flatbuffers::String *label() const {
    return GetPointer<const ::flatbuffers::String *>(VT_LABEL);
  }
  const ::flatbuffers::String *protocol() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PROTOCOL);
  }
  bool paused() const {
    return GetField<uint8_t>(VT_PAUSED, 0) != 0;
  }
  const ::flatbuffers::Vector<uint16_t> *subchannels() const {
    return GetPointer<const ::flatbuffers::Vector<uint16_t> *>(VT_SUBCHANNELS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_DATACONSUMERID) &&
           verifier.VerifyString(dataConsumerId()) &&
           VerifyOffsetRequired(verifier, VT_DATAPRODUCERID) &&
           verifier.VerifyString(dataProducerId()) &&
           VerifyOffsetRequired(verifier, VT_TYPE) &&
           verifier.VerifyString(type()) &&
           VerifyOffset(verifier, VT_SCTPSTREAMPARAMETERS) &&
           verifier.VerifyTable(sctpStreamParameters()) &&
           VerifyOffset(verifier, VT_LABEL) &&
           verifier.VerifyString(label()) &&
           VerifyOffset(verifier, VT_PROTOCOL) &&
           verifier.VerifyString(protocol()) &&
           VerifyField<uint8_t>(verifier, VT_PAUSED, 1) &&
           VerifyOffset(verifier, VT_SUBCHANNELS) &&
           verifier.VerifyVector(subchannels()) &&
           verifier.EndTable();
  }
};

struct ConsumeDataRequestBuilder {
  typedef ConsumeDataRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_dataConsumerId(::flatbuffers::Offset<::flatbuffers::String> dataConsumerId) {
    fbb_.AddOffset(ConsumeDataRequest::VT_DATACONSUMERID, dataConsumerId);
  }
  void add_dataProducerId(::flatbuffers::Offset<::flatbuffers::String> dataProducerId) {
    fbb_.AddOffset(ConsumeDataRequest::VT_DATAPRODUCERID, dataProducerId);
  }
  void add_type(::flatbuffers::Offset<::flatbuffers::String> type) {
    fbb_.AddOffset(ConsumeDataRequest::VT_TYPE, type);
  }
  void add_sctpStreamParameters(::flatbuffers::Offset<FBS::SctpParameters::SctpStreamParameters> sctpStreamParameters) {
    fbb_.AddOffset(ConsumeDataRequest::VT_SCTPSTREAMPARAMETERS, sctpStreamParameters);
  }
  void add_label(::flatbuffers::Offset<::flatbuffers::String> label) {
    fbb_.AddOffset(ConsumeDataRequest::VT_LABEL, label);
  }
  void add_protocol(::flatbuffers::Offset<::flatbuffers::String> protocol) {
    fbb_.AddOffset(ConsumeDataRequest::VT_PROTOCOL, protocol);
  }
  void add_paused(bool paused) {
    fbb_.AddElement<uint8_t>(ConsumeDataRequest::VT_PAUSED, static_cast<uint8_t>(paused), 0);
  }
  void add_subchannels(::flatbuffers::Offset<::flatbuffers::Vector<uint16_t>> subchannels) {
    fbb_.AddOffset(ConsumeDataRequest::VT_SUBCHANNELS, subchannels);
  }
  explicit ConsumeDataRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ConsumeDataRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ConsumeDataRequest>(end);
    fbb_.Required(o, ConsumeDataRequest::VT_DATACONSUMERID);
    fbb_.Required(o, ConsumeDataRequest::VT_DATAPRODUCERID);
    fbb_.Required(o, ConsumeDataRequest::VT_TYPE);
    return o;
  }
};

inline ::flatbuffers::Offset<ConsumeDataRequest> CreateConsumeDataRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> dataConsumerId = 0,
    ::flatbuffers::Offset<::flatbuffers::String> dataProducerId = 0,
    ::flatbuffers::Offset<::flatbuffers::String> type = 0,
    ::flatbuffers::Offset<FBS::SctpParameters::SctpStreamParameters> sctpStreamParameters = 0,
    ::flatbuffers::Offset<::flatbuffers::String> label = 0,
    ::flatbuffers::Offset<::flatbuffers::String> protocol = 0,
    bool paused = false,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint16_t>> subchannels = 0) {
  ConsumeDataRequestBuilder builder_(_fbb);
  builder_.add_subchannels(subchannels);
  builder_.add_protocol(protocol);
  builder_.add_label(label);
  builder_.add_sctpStreamParameters(sctpStreamParameters);
  builder_.add_type(type);
  builder_.add_dataProducerId(dataProducerId);
  builder_.add_dataConsumerId(dataConsumerId);
  builder_.add_paused(paused);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ConsumeDataRequest> CreateConsumeDataRequestDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *dataConsumerId = nullptr,
    const char *dataProducerId = nullptr,
    const char *type = nullptr,
    ::flatbuffers::Offset<FBS::SctpParameters::SctpStreamParameters> sctpStreamParameters = 0,
    const char *label = nullptr,
    const char *protocol = nullptr,
    bool paused = false,
    const std::vector<uint16_t> *subchannels = nullptr) {
  auto dataConsumerId__ = dataConsumerId ? _fbb.CreateString(dataConsumerId) : 0;
  auto dataProducerId__ = dataProducerId ? _fbb.CreateString(dataProducerId) : 0;
  auto type__ = type ? _fbb.CreateString(type) : 0;
  auto label__ = label ? _fbb.CreateString(label) : 0;
  auto protocol__ = protocol ? _fbb.CreateString(protocol) : 0;
  auto subchannels__ = subchannels ? _fbb.CreateVector<uint16_t>(*subchannels) : 0;
  return FBS::Transport::CreateConsumeDataRequest(
      _fbb,
      dataConsumerId__,
      dataProducerId__,
      type__,
      sctpStreamParameters,
      label__,
      protocol__,
      paused,
      subchannels__);
}

struct Tuple FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TupleBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return TupleTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LOCALIP = 4,
    VT_LOCALPORT = 6,
    VT_REMOTEIP = 8,
    VT_REMOTEPORT = 10,
    VT_PROTOCOL = 12
  };
  const ::flatbuffers::String *localIp() const {
    return GetPointer<const ::flatbuffers::String *>(VT_LOCALIP);
  }
  uint16_t localPort() const {
    return GetField<uint16_t>(VT_LOCALPORT, 0);
  }
  const ::flatbuffers::String *remoteIp() const {
    return GetPointer<const ::flatbuffers::String *>(VT_REMOTEIP);
  }
  uint16_t remotePort() const {
    return GetField<uint16_t>(VT_REMOTEPORT, 0);
  }
  FBS::Transport::Protocol protocol() const {
    return static_cast<FBS::Transport::Protocol>(GetField<uint8_t>(VT_PROTOCOL, 1));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_LOCALIP) &&
           verifier.VerifyString(localIp()) &&
           VerifyField<uint16_t>(verifier, VT_LOCALPORT, 2) &&
           VerifyOffset(verifier, VT_REMOTEIP) &&
           verifier.VerifyString(remoteIp()) &&
           VerifyField<uint16_t>(verifier, VT_REMOTEPORT, 2) &&
           VerifyField<uint8_t>(verifier, VT_PROTOCOL, 1) &&
           verifier.EndTable();
  }
};

struct TupleBuilder {
  typedef Tuple Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_localIp(::flatbuffers::Offset<::flatbuffers::String> localIp) {
    fbb_.AddOffset(Tuple::VT_LOCALIP, localIp);
  }
  void add_localPort(uint16_t localPort) {
    fbb_.AddElement<uint16_t>(Tuple::VT_LOCALPORT, localPort, 0);
  }
  void add_remoteIp(::flatbuffers::Offset<::flatbuffers::String> remoteIp) {
    fbb_.AddOffset(Tuple::VT_REMOTEIP, remoteIp);
  }
  void add_remotePort(uint16_t remotePort) {
    fbb_.AddElement<uint16_t>(Tuple::VT_REMOTEPORT, remotePort, 0);
  }
  void add_protocol(FBS::Transport::Protocol protocol) {
    fbb_.AddElement<uint8_t>(Tuple::VT_PROTOCOL, static_cast<uint8_t>(protocol), 1);
  }
  explicit TupleBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Tuple> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Tuple>(end);
    fbb_.Required(o, Tuple::VT_LOCALIP);
    return o;
  }
};

inline ::flatbuffers::Offset<Tuple> CreateTuple(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> localIp = 0,
    uint16_t localPort = 0,
    ::flatbuffers::Offset<::flatbuffers::String> remoteIp = 0,
    uint16_t remotePort = 0,
    FBS::Transport::Protocol protocol = FBS::Transport::Protocol::UDP) {
  TupleBuilder builder_(_fbb);
  builder_.add_remoteIp(remoteIp);
  builder_.add_localIp(localIp);
  builder_.add_remotePort(remotePort);
  builder_.add_localPort(localPort);
  builder_.add_protocol(protocol);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Tuple> CreateTupleDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *localIp = nullptr,
    uint16_t localPort = 0,
    const char *remoteIp = nullptr,
    uint16_t remotePort = 0,
    FBS::Transport::Protocol protocol = FBS::Transport::Protocol::UDP) {
  auto localIp__ = localIp ? _fbb.CreateString(localIp) : 0;
  auto remoteIp__ = remoteIp ? _fbb.CreateString(remoteIp) : 0;
  return FBS::Transport::CreateTuple(
      _fbb,
      localIp__,
      localPort,
      remoteIp__,
      remotePort,
      protocol);
}

struct SrtpParameters FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SrtpParametersBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SrtpParametersTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CRYPTOSUITE = 4,
    VT_KEYBASE64 = 6
  };
  const ::flatbuffers::String *cryptoSuite() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CRYPTOSUITE);
  }
  const ::flatbuffers::String *keyBase64() const {
    return GetPointer<const ::flatbuffers::String *>(VT_KEYBASE64);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_CRYPTOSUITE) &&
           verifier.VerifyString(cryptoSuite()) &&
           VerifyOffsetRequired(verifier, VT_KEYBASE64) &&
           verifier.VerifyString(keyBase64()) &&
           verifier.EndTable();
  }
};

struct SrtpParametersBuilder {
  typedef SrtpParameters Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_cryptoSuite(::flatbuffers::Offset<::flatbuffers::String> cryptoSuite) {
    fbb_.AddOffset(SrtpParameters::VT_CRYPTOSUITE, cryptoSuite);
  }
  void add_keyBase64(::flatbuffers::Offset<::flatbuffers::String> keyBase64) {
    fbb_.AddOffset(SrtpParameters::VT_KEYBASE64, keyBase64);
  }
  explicit SrtpParametersBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SrtpParameters> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SrtpParameters>(end);
    fbb_.Required(o, SrtpParameters::VT_CRYPTOSUITE);
    fbb_.Required(o, SrtpParameters::VT_KEYBASE64);
    return o;
  }
};

inline ::flatbuffers::Offset<SrtpParameters> CreateSrtpParameters(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> cryptoSuite = 0,
    ::flatbuffers::Offset<::flatbuffers::String> keyBase64 = 0) {
  SrtpParametersBuilder builder_(_fbb);
  builder_.add_keyBase64(keyBase64);
  builder_.add_cryptoSuite(cryptoSuite);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<SrtpParameters> CreateSrtpParametersDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *cryptoSuite = nullptr,
    const char *keyBase64 = nullptr) {
  auto cryptoSuite__ = cryptoSuite ? _fbb.CreateString(cryptoSuite) : 0;
  auto keyBase64__ = keyBase64 ? _fbb.CreateString(keyBase64) : 0;
  return FBS::Transport::CreateSrtpParameters(
      _fbb,
      cryptoSuite__,
      keyBase64__);
}

struct RtpListener FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RtpListenerBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return RtpListenerTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SSRCTABLE = 4,
    VT_MIDTABLE = 6,
    VT_RIDTABLE = 8
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<FBS::Common::Uint32String>> *ssrcTable() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<FBS::Common::Uint32String>> *>(VT_SSRCTABLE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<FBS::Common::StringString>> *midTable() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<FBS::Common::StringString>> *>(VT_MIDTABLE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<FBS::Common::StringString>> *ridTable() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<FBS::Common::StringString>> *>(VT_RIDTABLE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_SSRCTABLE) &&
           verifier.VerifyVector(ssrcTable()) &&
           verifier.VerifyVectorOfTables(ssrcTable()) &&
           VerifyOffsetRequired(verifier, VT_MIDTABLE) &&
           verifier.VerifyVector(midTable()) &&
           verifier.VerifyVectorOfTables(midTable()) &&
           VerifyOffsetRequired(verifier, VT_RIDTABLE) &&
           verifier.VerifyVector(ridTable()) &&
           verifier.VerifyVectorOfTables(ridTable()) &&
           verifier.EndTable();
  }
};

struct RtpListenerBuilder {
  typedef RtpListener Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_ssrcTable(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<FBS::Common::Uint32String>>> ssrcTable) {
    fbb_.AddOffset(RtpListener::VT_SSRCTABLE, ssrcTable);
  }
  void add_midTable(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<FBS::Common::StringString>>> midTable) {
    fbb_.AddOffset(RtpListener::VT_MIDTABLE, midTable);
  }
  void add_ridTable(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<FBS::Common::StringString>>> ridTable) {
    fbb_.AddOffset(RtpListener::VT_RIDTABLE, ridTable);
  }
  explicit RtpListenerBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RtpListener> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RtpListener>(end);
    fbb_.Required(o, RtpListener::VT_SSRCTABLE);
    fbb_.Required(o, RtpListener::VT_MIDTABLE);
    fbb_.Required(o, RtpListener::VT_RIDTABLE);
    return o;
  }
};

inline ::flatbuffers::Offset<RtpListener> CreateRtpListener(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<FBS::Common::Uint32String>>> ssrcTable = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<FBS::Common::StringString>>> midTable = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<FBS::Common::StringString>>> ridTable = 0) {
  RtpListenerBuilder builder_(_fbb);
  builder_.add_ridTable(ridTable);
  builder_.add_midTable(midTable);
  builder_.add_ssrcTable(ssrcTable);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<RtpListener> CreateRtpListenerDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<FBS::Common::Uint32String>> *ssrcTable = nullptr,
    const std::vector<::flatbuffers::Offset<FBS::Common::StringString>> *midTable = nullptr,
    const std::vector<::flatbuffers::Offset<FBS::Common::StringString>> *ridTable = nullptr) {
  auto ssrcTable__ = ssrcTable ? _fbb.CreateVector<::flatbuffers::Offset<FBS::Common::Uint32String>>(*ssrcTable) : 0;
  auto midTable__ = midTable ? _fbb.CreateVector<::flatbuffers::Offset<FBS::Common::StringString>>(*midTable) : 0;
  auto ridTable__ = ridTable ? _fbb.CreateVector<::flatbuffers::Offset<FBS::Common::StringString>>(*ridTable) : 0;
  return FBS::Transport::CreateRtpListener(
      _fbb,
      ssrcTable__,
      midTable__,
      ridTable__);
}

struct SctpListener FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SctpListenerBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SctpListenerTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STREAMIDTABLE = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<FBS::Common::Uint16String>> *streamIdTable() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<FBS::Common::Uint16String>> *>(VT_STREAMIDTABLE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_STREAMIDTABLE) &&
           verifier.VerifyVector(streamIdTable()) &&
           verifier.VerifyVectorOfTables(streamIdTable()) &&
           verifier.EndTable();
  }
};

struct SctpListenerBuilder {
  typedef SctpListener Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_streamIdTable(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<FBS::Common::Uint16String>>> streamIdTable) {
    fbb_.AddOffset(SctpListener::VT_STREAMIDTABLE, streamIdTable);
  }
  explicit SctpListenerBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SctpListener> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SctpListener>(end);
    fbb_.Required(o, SctpListener::VT_STREAMIDTABLE);
    return o;
  }
};

inline ::flatbuffers::Offset<SctpListener> CreateSctpListener(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<FBS::Common::Uint16String>>> streamIdTable = 0) {
  SctpListenerBuilder builder_(_fbb);
  builder_.add_streamIdTable(streamIdTable);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<SctpListener> CreateSctpListenerDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<FBS::Common::Uint16String>> *streamIdTable = nullptr) {
  auto streamIdTable__ = streamIdTable ? _fbb.CreateVector<::flatbuffers::Offset<FBS::Common::Uint16String>>(*streamIdTable) : 0;
  return FBS::Transport::CreateSctpListener(
      _fbb,
      streamIdTable__);
}

struct RecvRtpHeaderExtensions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RecvRtpHeaderExtensionsBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return RecvRtpHeaderExtensionsTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MID = 4,
    VT_RID = 6,
    VT_RRID = 8,
    VT_ABSSENDTIME = 10,
    VT_TRANSPORTWIDECC01 = 12
  };
  ::flatbuffers::Optional<uint8_t> mid() const {
    return GetOptional<uint8_t, uint8_t>(VT_MID);
  }
  ::flatbuffers::Optional<uint8_t> rid() const {
    return GetOptional<uint8_t, uint8_t>(VT_RID);
  }
  ::flatbuffers::Optional<uint8_t> rrid() const {
    return GetOptional<uint8_t, uint8_t>(VT_RRID);
  }
  ::flatbuffers::Optional<uint8_t> absSendTime() const {
    return GetOptional<uint8_t, uint8_t>(VT_ABSSENDTIME);
  }
  ::flatbuffers::Optional<uint8_t> transportWideCc01() const {
    return GetOptional<uint8_t, uint8_t>(VT_TRANSPORTWIDECC01);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_MID, 1) &&
           VerifyField<uint8_t>(verifier, VT_RID, 1) &&
           VerifyField<uint8_t>(verifier, VT_RRID, 1) &&
           VerifyField<uint8_t>(verifier, VT_ABSSENDTIME, 1) &&
           VerifyField<uint8_t>(verifier, VT_TRANSPORTWIDECC01, 1) &&
           verifier.EndTable();
  }
};

struct RecvRtpHeaderExtensionsBuilder {
  typedef RecvRtpHeaderExtensions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_mid(uint8_t mid) {
    fbb_.AddElement<uint8_t>(RecvRtpHeaderExtensions::VT_MID, mid);
  }
  void add_rid(uint8_t rid) {
    fbb_.AddElement<uint8_t>(RecvRtpHeaderExtensions::VT_RID, rid);
  }
  void add_rrid(uint8_t rrid) {
    fbb_.AddElement<uint8_t>(RecvRtpHeaderExtensions::VT_RRID, rrid);
  }
  void add_absSendTime(uint8_t absSendTime) {
    fbb_.AddElement<uint8_t>(RecvRtpHeaderExtensions::VT_ABSSENDTIME, absSendTime);
  }
  void add_transportWideCc01(uint8_t transportWideCc01) {
    fbb_.AddElement<uint8_t>(RecvRtpHeaderExtensions::VT_TRANSPORTWIDECC01, transportWideCc01);
  }
  explicit RecvRtpHeaderExtensionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RecvRtpHeaderExtensions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RecvRtpHeaderExtensions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RecvRtpHeaderExtensions> CreateRecvRtpHeaderExtensions(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Optional<uint8_t> mid = ::flatbuffers::nullopt,
    ::flatbuffers::Optional<uint8_t> rid = ::flatbuffers::nullopt,
    ::flatbuffers::Optional<uint8_t> rrid = ::flatbuffers::nullopt,
    ::flatbuffers::Optional<uint8_t> absSendTime = ::flatbuffers::nullopt,
    ::flatbuffers::Optional<uint8_t> transportWideCc01 = ::flatbuffers::nullopt) {
  RecvRtpHeaderExtensionsBuilder builder_(_fbb);
  if(transportWideCc01) { builder_.add_transportWideCc01(*transportWideCc01); }
  if(absSendTime) { builder_.add_absSendTime(*absSendTime); }
  if(rrid) { builder_.add_rrid(*rrid); }
  if(rid) { builder_.add_rid(*rid); }
  if(mid) { builder_.add_mid(*mid); }
  return builder_.Finish();
}

struct Options FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef OptionsBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return OptionsTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DIRECT = 4,
    VT_MAXMESSAGESIZE = 6,
    VT_INITIALAVAILABLEOUTGOINGBITRATE = 8,
    VT_ENABLESCTP = 10,
    VT_NUMSCTPSTREAMS = 12,
    VT_MAXSCTPMESSAGESIZE = 14,
    VT_SCTPSENDBUFFERSIZE = 16,
    VT_ISDATACHANNEL = 18
  };
  bool direct() const {
    return GetField<uint8_t>(VT_DIRECT, 0) != 0;
  }
  uint32_t maxMessageSize() const {
    return GetField<uint32_t>(VT_MAXMESSAGESIZE, 0);
  }
  uint32_t initialAvailableOutgoingBitrate() const {
    return GetField<uint32_t>(VT_INITIALAVAILABLEOUTGOINGBITRATE, 0);
  }
  bool enableSctp() const {
    return GetField<uint8_t>(VT_ENABLESCTP, 0) != 0;
  }
  const FBS::SctpParameters::NumSctpStreams *numSctpStreams() const {
    return GetPointer<const FBS::SctpParameters::NumSctpStreams *>(VT_NUMSCTPSTREAMS);
  }
  uint32_t maxSctpMessageSize() const {
    return GetField<uint32_t>(VT_MAXSCTPMESSAGESIZE, 0);
  }
  uint32_t sctpSendBufferSize() const {
    return GetField<uint32_t>(VT_SCTPSENDBUFFERSIZE, 0);
  }
  bool isDataChannel() const {
    return GetField<uint8_t>(VT_ISDATACHANNEL, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_DIRECT, 1) &&
           VerifyField<uint32_t>(verifier, VT_MAXMESSAGESIZE, 4) &&
           VerifyField<uint32_t>(verifier, VT_INITIALAVAILABLEOUTGOINGBITRATE, 4) &&
           VerifyField<uint8_t>(verifier, VT_ENABLESCTP, 1) &&
           VerifyOffset(verifier, VT_NUMSCTPSTREAMS) &&
           verifier.VerifyTable(numSctpStreams()) &&
           VerifyField<uint32_t>(verifier, VT_MAXSCTPMESSAGESIZE, 4) &&
           VerifyField<uint32_t>(verifier, VT_SCTPSENDBUFFERSIZE, 4) &&
           VerifyField<uint8_t>(verifier, VT_ISDATACHANNEL, 1) &&
           verifier.EndTable();
  }
};

struct OptionsBuilder {
  typedef Options Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_direct(bool direct) {
    fbb_.AddElement<uint8_t>(Options::VT_DIRECT, static_cast<uint8_t>(direct), 0);
  }
  void add_maxMessageSize(uint32_t maxMessageSize) {
    fbb_.AddElement<uint32_t>(Options::VT_MAXMESSAGESIZE, maxMessageSize, 0);
  }
  void add_initialAvailableOutgoingBitrate(uint32_t initialAvailableOutgoingBitrate) {
    fbb_.AddElement<uint32_t>(Options::VT_INITIALAVAILABLEOUTGOINGBITRATE, initialAvailableOutgoingBitrate, 0);
  }
  void add_enableSctp(bool enableSctp) {
    fbb_.AddElement<uint8_t>(Options::VT_ENABLESCTP, static_cast<uint8_t>(enableSctp), 0);
  }
  void add_numSctpStreams(::flatbuffers::Offset<FBS::SctpParameters::NumSctpStreams> numSctpStreams) {
    fbb_.AddOffset(Options::VT_NUMSCTPSTREAMS, numSctpStreams);
  }
  void add_maxSctpMessageSize(uint32_t maxSctpMessageSize) {
    fbb_.AddElement<uint32_t>(Options::VT_MAXSCTPMESSAGESIZE, maxSctpMessageSize, 0);
  }
  void add_sctpSendBufferSize(uint32_t sctpSendBufferSize) {
    fbb_.AddElement<uint32_t>(Options::VT_SCTPSENDBUFFERSIZE, sctpSendBufferSize, 0);
  }
  void add_isDataChannel(bool isDataChannel) {
    fbb_.AddElement<uint8_t>(Options::VT_ISDATACHANNEL, static_cast<uint8_t>(isDataChannel), 0);
  }
  explicit OptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Options> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Options>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Options> CreateOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool direct = false,
    uint32_t maxMessageSize = 0,
    uint32_t initialAvailableOutgoingBitrate = 0,
    bool enableSctp = false,
    ::flatbuffers::Offset<FBS::SctpParameters::NumSctpStreams> numSctpStreams = 0,
    uint32_t maxSctpMessageSize = 0,
    uint32_t sctpSendBufferSize = 0,
    bool isDataChannel = false) {
  OptionsBuilder builder_(_fbb);
  builder_.add_sctpSendBufferSize(sctpSendBufferSize);
  builder_.add_maxSctpMessageSize(maxSctpMessageSize);
  builder_.add_numSctpStreams(numSctpStreams);
  builder_.add_initialAvailableOutgoingBitrate(initialAvailableOutgoingBitrate);
  builder_.add_maxMessageSize(maxMessageSize);
  builder_.add_isDataChannel(isDataChannel);
  builder_.add_enableSctp(enableSctp);
  builder_.add_direct(direct);
  return builder_.Finish();
}

struct Dump FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DumpBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return DumpTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_DIRECT = 6,
    VT_PRODUCERIDS = 8,
    VT_CONSUMERIDS = 10,
    VT_MAPSSRCCONSUMERID = 12,
    VT_MAPRTXSSRCCONSUMERID = 14,
    VT_DATAPRODUCERIDS = 16,
    VT_DATACONSUMERIDS = 18,
    VT_RECVRTPHEADEREXTENSIONS = 20,
    VT_RTPLISTENER = 22,
    VT_MAXMESSAGESIZE = 24,
    VT_SCTPPARAMETERS = 26,
    VT_SCTPSTATE = 28,
    VT_SCTPLISTENER = 30,
    VT_TRACEEVENTTYPES = 32
  };
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  bool direct() const {
    return GetField<uint8_t>(VT_DIRECT, 0) != 0;
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *producerIds() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_PRODUCERIDS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *consumerIds() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_CONSUMERIDS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<FBS::Common::Uint32String>> *mapSsrcConsumerId() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<FBS::Common::Uint32String>> *>(VT_MAPSSRCCONSUMERID);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<FBS::Common::Uint32String>> *mapRtxSsrcConsumerId() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<FBS::Common::Uint32String>> *>(VT_MAPRTXSSRCCONSUMERID);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *dataProducerIds() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_DATAPRODUCERIDS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *dataConsumerIds() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_DATACONSUMERIDS);
  }
  const FBS::Transport::RecvRtpHeaderExtensions *recvRtpHeaderExtensions() const {
    return GetPointer<const FBS::Transport::RecvRtpHeaderExtensions *>(VT_RECVRTPHEADEREXTENSIONS);
  }
  const FBS::Transport::RtpListener *rtpListener() const {
    return GetPointer<const FBS::Transport::RtpListener *>(VT_RTPLISTENER);
  }
  uint32_t maxMessageSize() const {
    return GetField<uint32_t>(VT_MAXMESSAGESIZE, 0);
  }
  const FBS::SctpParameters::SctpParameters *sctpParameters() const {
    return GetPointer<const FBS::SctpParameters::SctpParameters *>(VT_SCTPPARAMETERS);
  }
  ::flatbuffers::Optional<FBS::SctpAssociation::SctpState> sctpState() const {
    return GetOptional<uint8_t, FBS::SctpAssociation::SctpState>(VT_SCTPSTATE);
  }
  const FBS::Transport::SctpListener *sctpListener() const {
    return GetPointer<const FBS::Transport::SctpListener *>(VT_SCTPLISTENER);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *traceEventTypes() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_TRACEEVENTTYPES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyField<uint8_t>(verifier, VT_DIRECT, 1) &&
           VerifyOffsetRequired(verifier, VT_PRODUCERIDS) &&
           verifier.VerifyVector(producerIds()) &&
           verifier.VerifyVectorOfStrings(producerIds()) &&
           VerifyOffsetRequired(verifier, VT_CONSUMERIDS) &&
           verifier.VerifyVector(consumerIds()) &&
           verifier.VerifyVectorOfStrings(consumerIds()) &&
           VerifyOffsetRequired(verifier, VT_MAPSSRCCONSUMERID) &&
           verifier.VerifyVector(mapSsrcConsumerId()) &&
           verifier.VerifyVectorOfTables(mapSsrcConsumerId()) &&
           VerifyOffsetRequired(verifier, VT_MAPRTXSSRCCONSUMERID) &&
           verifier.VerifyVector(mapRtxSsrcConsumerId()) &&
           verifier.VerifyVectorOfTables(mapRtxSsrcConsumerId()) &&
           VerifyOffsetRequired(verifier, VT_DATAPRODUCERIDS) &&
           verifier.VerifyVector(dataProducerIds()) &&
           verifier.VerifyVectorOfStrings(dataProducerIds()) &&
           VerifyOffsetRequired(verifier, VT_DATACONSUMERIDS) &&
           verifier.VerifyVector(dataConsumerIds()) &&
           verifier.VerifyVectorOfStrings(dataConsumerIds()) &&
           VerifyOffsetRequired(verifier, VT_RECVRTPHEADEREXTENSIONS) &&
           verifier.VerifyTable(recvRtpHeaderExtensions()) &&
           VerifyOffsetRequired(verifier, VT_RTPLISTENER) &&
           verifier.VerifyTable(rtpListener()) &&
           VerifyField<uint32_t>(verifier, VT_MAXMESSAGESIZE, 4) &&
           VerifyOffset(verifier, VT_SCTPPARAMETERS) &&
           verifier.VerifyTable(sctpParameters()) &&
           VerifyField<uint8_t>(verifier, VT_SCTPSTATE, 1) &&
           VerifyOffset(verifier, VT_SCTPLISTENER) &&
           verifier.VerifyTable(sctpListener()) &&
           VerifyOffsetRequired(verifier, VT_TRACEEVENTTYPES) &&
           verifier.VerifyVector(traceEventTypes()) &&
           verifier.VerifyVectorOfStrings(traceEventTypes()) &&
           verifier.EndTable();
  }
};

struct DumpBuilder {
  typedef Dump Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(Dump::VT_ID, id);
  }
  void add_direct(bool direct) {
    fbb_.AddElement<uint8_t>(Dump::VT_DIRECT, static_cast<uint8_t>(direct), 0);
  }
  void add_producerIds(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> producerIds) {
    fbb_.AddOffset(Dump::VT_PRODUCERIDS, producerIds);
  }
  void add_consumerIds(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> consumerIds) {
    fbb_.AddOffset(Dump::VT_CONSUMERIDS, consumerIds);
  }
  void add_mapSsrcConsumerId(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<FBS::Common::Uint32String>>> mapSsrcConsumerId) {
    fbb_.AddOffset(Dump::VT_MAPSSRCCONSUMERID, mapSsrcConsumerId);
  }
  void add_mapRtxSsrcConsumerId(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<FBS::Common::Uint32String>>> mapRtxSsrcConsumerId) {
    fbb_.AddOffset(Dump::VT_MAPRTXSSRCCONSUMERID, mapRtxSsrcConsumerId);
  }
  void add_dataProducerIds(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> dataProducerIds) {
    fbb_.AddOffset(Dump::VT_DATAPRODUCERIDS, dataProducerIds);
  }
  void add_dataConsumerIds(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> dataConsumerIds) {
    fbb_.AddOffset(Dump::VT_DATACONSUMERIDS, dataConsumerIds);
  }
  void add_recvRtpHeaderExtensions(::flatbuffers::Offset<FBS::Transport::RecvRtpHeaderExtensions> recvRtpHeaderExtensions) {
    fbb_.AddOffset(Dump::VT_RECVRTPHEADEREXTENSIONS, recvRtpHeaderExtensions);
  }
  void add_rtpListener(::flatbuffers::Offset<FBS::Transport::RtpListener> rtpListener) {
    fbb_.AddOffset(Dump::VT_RTPLISTENER, rtpListener);
  }
  void add_maxMessageSize(uint32_t maxMessageSize) {
    fbb_.AddElement<uint32_t>(Dump::VT_MAXMESSAGESIZE, maxMessageSize, 0);
  }
  void add_sctpParameters(::flatbuffers::Offset<FBS::SctpParameters::SctpParameters> sctpParameters) {
    fbb_.AddOffset(Dump::VT_SCTPPARAMETERS, sctpParameters);
  }
  void add_sctpState(FBS::SctpAssociation::SctpState sctpState) {
    fbb_.AddElement<uint8_t>(Dump::VT_SCTPSTATE, static_cast<uint8_t>(sctpState));
  }
  void add_sctpListener(::flatbuffers::Offset<FBS::Transport::SctpListener> sctpListener) {
    fbb_.AddOffset(Dump::VT_SCTPLISTENER, sctpListener);
  }
  void add_traceEventTypes(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> traceEventTypes) {
    fbb_.AddOffset(Dump::VT_TRACEEVENTTYPES, traceEventTypes);
  }
  explicit DumpBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Dump> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Dump>(end);
    fbb_.Required(o, Dump::VT_ID);
    fbb_.Required(o, Dump::VT_PRODUCERIDS);
    fbb_.Required(o, Dump::VT_CONSUMERIDS);
    fbb_.Required(o, Dump::VT_MAPSSRCCONSUMERID);
    fbb_.Required(o, Dump::VT_MAPRTXSSRCCONSUMERID);
    fbb_.Required(o, Dump::VT_DATAPRODUCERIDS);
    fbb_.Required(o, Dump::VT_DATACONSUMERIDS);
    fbb_.Required(o, Dump::VT_RECVRTPHEADEREXTENSIONS);
    fbb_.Required(o, Dump::VT_RTPLISTENER);
    fbb_.Required(o, Dump::VT_TRACEEVENTTYPES);
    return o;
  }
};

inline ::flatbuffers::Offset<Dump> CreateDump(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0,
    bool direct = false,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> producerIds = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> consumerIds = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<FBS::Common::Uint32String>>> mapSsrcConsumerId = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<FBS::Common::Uint32String>>> mapRtxSsrcConsumerId = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> dataProducerIds = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> dataConsumerIds = 0,
    ::flatbuffers::Offset<FBS::Transport::RecvRtpHeaderExtensions> recvRtpHeaderExtensions = 0,
    ::flatbuffers::Offset<FBS::Transport::RtpListener> rtpListener = 0,
    uint32_t maxMessageSize = 0,
    ::flatbuffers::Offset<FBS::SctpParameters::SctpParameters> sctpParameters = 0,
    ::flatbuffers::Optional<FBS::SctpAssociation::SctpState> sctpState = ::flatbuffers::nullopt,
    ::flatbuffers::Offset<FBS::Transport::SctpListener> sctpListener = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> traceEventTypes = 0) {
  DumpBuilder builder_(_fbb);
  builder_.add_traceEventTypes(traceEventTypes);
  builder_.add_sctpListener(sctpListener);
  builder_.add_sctpParameters(sctpParameters);
  builder_.add_maxMessageSize(maxMessageSize);
  builder_.add_rtpListener(rtpListener);
  builder_.add_recvRtpHeaderExtensions(recvRtpHeaderExtensions);
  builder_.add_dataConsumerIds(dataConsumerIds);
  builder_.add_dataProducerIds(dataProducerIds);
  builder_.add_mapRtxSsrcConsumerId(mapRtxSsrcConsumerId);
  builder_.add_mapSsrcConsumerId(mapSsrcConsumerId);
  builder_.add_consumerIds(consumerIds);
  builder_.add_producerIds(producerIds);
  builder_.add_id(id);
  if(sctpState) { builder_.add_sctpState(*sctpState); }
  builder_.add_direct(direct);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Dump> CreateDumpDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    bool direct = false,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *producerIds = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *consumerIds = nullptr,
    const std::vector<::flatbuffers::Offset<FBS::Common::Uint32String>> *mapSsrcConsumerId = nullptr,
    const std::vector<::flatbuffers::Offset<FBS::Common::Uint32String>> *mapRtxSsrcConsumerId = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *dataProducerIds = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *dataConsumerIds = nullptr,
    ::flatbuffers::Offset<FBS::Transport::RecvRtpHeaderExtensions> recvRtpHeaderExtensions = 0,
    ::flatbuffers::Offset<FBS::Transport::RtpListener> rtpListener = 0,
    uint32_t maxMessageSize = 0,
    ::flatbuffers::Offset<FBS::SctpParameters::SctpParameters> sctpParameters = 0,
    ::flatbuffers::Optional<FBS::SctpAssociation::SctpState> sctpState = ::flatbuffers::nullopt,
    ::flatbuffers::Offset<FBS::Transport::SctpListener> sctpListener = 0,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *traceEventTypes = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto producerIds__ = producerIds ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*producerIds) : 0;
  auto consumerIds__ = consumerIds ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*consumerIds) : 0;
  auto mapSsrcConsumerId__ = mapSsrcConsumerId ? _fbb.CreateVector<::flatbuffers::Offset<FBS::Common::Uint32String>>(*mapSsrcConsumerId) : 0;
  auto mapRtxSsrcConsumerId__ = mapRtxSsrcConsumerId ? _fbb.CreateVector<::flatbuffers::Offset<FBS::Common::Uint32String>>(*mapRtxSsrcConsumerId) : 0;
  auto dataProducerIds__ = dataProducerIds ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*dataProducerIds) : 0;
  auto dataConsumerIds__ = dataConsumerIds ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*dataConsumerIds) : 0;
  auto traceEventTypes__ = traceEventTypes ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*traceEventTypes) : 0;
  return FBS::Transport::CreateDump(
      _fbb,
      id__,
      direct,
      producerIds__,
      consumerIds__,
      mapSsrcConsumerId__,
      mapRtxSsrcConsumerId__,
      dataProducerIds__,
      dataConsumerIds__,
      recvRtpHeaderExtensions,
      rtpListener,
      maxMessageSize,
      sctpParameters,
      sctpState,
      sctpListener,
      traceEventTypes__);
}

struct Stats FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StatsBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return StatsTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TRANSPORTID = 4,
    VT_TIMESTAMP = 6,
    VT_SCTPSTATE = 8,
    VT_BYTESRECEIVED = 10,
    VT_RECVBITRATE = 12,
    VT_BYTESSENT = 14,
    VT_SENDBITRATE = 16,
    VT_RTPBYTESRECEIVED = 18,
    VT_RTPRECVBITRATE = 20,
    VT_RTPBYTESSENT = 22,
    VT_RTPSENDBITRATE = 24,
    VT_RTXBYTESRECEIVED = 26,
    VT_RTXRECVBITRATE = 28,
    VT_RTXBYTESSENT = 30,
    VT_RTXSENDBITRATE = 32,
    VT_PROBATIONBYTESSENT = 34,
    VT_PROBATIONSENDBITRATE = 36,
    VT_AVAILABLEOUTGOINGBITRATE = 38,
    VT_AVAILABLEINCOMINGBITRATE = 40,
    VT_MAXINCOMINGBITRATE = 42,
    VT_MAXOUTGOINGBITRATE = 44,
    VT_MINOUTGOINGBITRATE = 46,
    VT_RTPPACKETLOSSRECEIVED = 48,
    VT_RTPPACKETLOSSSENT = 50
  };
  const ::flatbuffers::String *transportId() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TRANSPORTID);
  }
  uint64_t timestamp() const {
    return GetField<uint64_t>(VT_TIMESTAMP, 0);
  }
  ::flatbuffers::Optional<FBS::SctpAssociation::SctpState> sctpState() const {
    return GetOptional<uint8_t, FBS::SctpAssociation::SctpState>(VT_SCTPSTATE);
  }
  uint64_t bytesReceived() const {
    return GetField<uint64_t>(VT_BYTESRECEIVED, 0);
  }
  uint32_t recvBitrate() const {
    return GetField<uint32_t>(VT_RECVBITRATE, 0);
  }
  uint64_t bytesSent() const {
    return GetField<uint64_t>(VT_BYTESSENT, 0);
  }
  uint32_t sendBitrate() const {
    return GetField<uint32_t>(VT_SENDBITRATE, 0);
  }
  uint64_t rtpBytesReceived() const {
    return GetField<uint64_t>(VT_RTPBYTESRECEIVED, 0);
  }
  uint32_t rtpRecvBitrate() const {
    return GetField<uint32_t>(VT_RTPRECVBITRATE, 0);
  }
  uint64_t rtpBytesSent() const {
    return GetField<uint64_t>(VT_RTPBYTESSENT, 0);
  }
  uint32_t rtpSendBitrate() const {
    return GetField<uint32_t>(VT_RTPSENDBITRATE, 0);
  }
  uint64_t rtxBytesReceived() const {
    return GetField<uint64_t>(VT_RTXBYTESRECEIVED, 0);
  }
  uint32_t rtxRecvBitrate() const {
    return GetField<uint32_t>(VT_RTXRECVBITRATE, 0);
  }
  uint64_t rtxBytesSent() const {
    return GetField<uint64_t>(VT_RTXBYTESSENT, 0);
  }
  uint32_t rtxSendBitrate() const {
    return GetField<uint32_t>(VT_RTXSENDBITRATE, 0);
  }
  uint64_t probationBytesSent() const {
    return GetField<uint64_t>(VT_PROBATIONBYTESSENT, 0);
  }
  uint32_t probationSendBitrate() const {
    return GetField<uint32_t>(VT_PROBATIONSENDBITRATE, 0);
  }
  ::flatbuffers::Optional<uint32_t> availableOutgoingBitrate() const {
    return GetOptional<uint32_t, uint32_t>(VT_AVAILABLEOUTGOINGBITRATE);
  }
  ::flatbuffers::Optional<uint32_t> availableIncomingBitrate() const {
    return GetOptional<uint32_t, uint32_t>(VT_AVAILABLEINCOMINGBITRATE);
  }
  uint32_t maxIncomingBitrate() const {
    return GetField<uint32_t>(VT_MAXINCOMINGBITRATE, 0);
  }
  uint32_t maxOutgoingBitrate() const {
    return GetField<uint32_t>(VT_MAXOUTGOINGBITRATE, 0);
  }
  uint32_t minOutgoingBitrate() const {
    return GetField<uint32_t>(VT_MINOUTGOINGBITRATE, 0);
  }
  ::flatbuffers::Optional<double> rtpPacketLossReceived() const {
    return GetOptional<double, double>(VT_RTPPACKETLOSSRECEIVED);
  }
  ::flatbuffers::Optional<double> rtpPacketLossSent() const {
    return GetOptional<double, double>(VT_RTPPACKETLOSSSENT);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_TRANSPORTID) &&
           verifier.VerifyString(transportId()) &&
           VerifyField<uint64_t>(verifier, VT_TIMESTAMP, 8) &&
           VerifyField<uint8_t>(verifier, VT_SCTPSTATE, 1) &&
           VerifyField<uint64_t>(verifier, VT_BYTESRECEIVED, 8) &&
           VerifyField<uint32_t>(verifier, VT_RECVBITRATE, 4) &&
           VerifyField<uint64_t>(verifier, VT_BYTESSENT, 8) &&
           VerifyField<uint32_t>(verifier, VT_SENDBITRATE, 4) &&
           VerifyField<uint64_t>(verifier, VT_RTPBYTESRECEIVED, 8) &&
           VerifyField<uint32_t>(verifier, VT_RTPRECVBITRATE, 4) &&
           VerifyField<uint64_t>(verifier, VT_RTPBYTESSENT, 8) &&
           VerifyField<uint32_t>(verifier, VT_RTPSENDBITRATE, 4) &&
           VerifyField<uint64_t>(verifier, VT_RTXBYTESRECEIVED, 8) &&
           VerifyField<uint32_t>(verifier, VT_RTXRECVBITRATE, 4) &&
           VerifyField<uint64_t>(verifier, VT_RTXBYTESSENT, 8) &&
           VerifyField<uint32_t>(verifier, VT_RTXSENDBITRATE, 4) &&
           VerifyField<uint64_t>(verifier, VT_PROBATIONBYTESSENT, 8) &&
           VerifyField<uint32_t>(verifier, VT_PROBATIONSENDBITRATE, 4) &&
           VerifyField<uint32_t>(verifier, VT_AVAILABLEOUTGOINGBITRATE, 4) &&
           VerifyField<uint32_t>(verifier, VT_AVAILABLEINCOMINGBITRATE, 4) &&
           VerifyField<uint32_t>(verifier, VT_MAXINCOMINGBITRATE, 4) &&
           VerifyField<uint32_t>(verifier, VT_MAXOUTGOINGBITRATE, 4) &&
           VerifyField<uint32_t>(verifier, VT_MINOUTGOINGBITRATE, 4) &&
           VerifyField<double>(verifier, VT_RTPPACKETLOSSRECEIVED, 8) &&
           VerifyField<double>(verifier, VT_RTPPACKETLOSSSENT, 8) &&
           verifier.EndTable();
  }
};

struct StatsBuilder {
  typedef Stats Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_transportId(::flatbuffers::Offset<::flatbuffers::String> transportId) {
    fbb_.AddOffset(Stats::VT_TRANSPORTID, transportId);
  }
  void add_timestamp(uint64_t timestamp) {
    fbb_.AddElement<uint64_t>(Stats::VT_TIMESTAMP, timestamp, 0);
  }
  void add_sctpState(FBS::SctpAssociation::SctpState sctpState) {
    fbb_.AddElement<uint8_t>(Stats::VT_SCTPSTATE, static_cast<uint8_t>(sctpState));
  }
  void add_bytesReceived(uint64_t bytesReceived) {
    fbb_.AddElement<uint64_t>(Stats::VT_BYTESRECEIVED, bytesReceived, 0);
  }
  void add_recvBitrate(uint32_t recvBitrate) {
    fbb_.AddElement<uint32_t>(Stats::VT_RECVBITRATE, recvBitrate, 0);
  }
  void add_bytesSent(uint64_t bytesSent) {
    fbb_.AddElement<uint64_t>(Stats::VT_BYTESSENT, bytesSent, 0);
  }
  void add_sendBitrate(uint32_t sendBitrate) {
    fbb_.AddElement<uint32_t>(Stats::VT_SENDBITRATE, sendBitrate, 0);
  }
  void add_rtpBytesReceived(uint64_t rtpBytesReceived) {
    fbb_.AddElement<uint64_t>(Stats::VT_RTPBYTESRECEIVED, rtpBytesReceived, 0);
  }
  void add_rtpRecvBitrate(uint32_t rtpRecvBitrate) {
    fbb_.AddElement<uint32_t>(Stats::VT_RTPRECVBITRATE, rtpRecvBitrate, 0);
  }
  void add_rtpBytesSent(uint64_t rtpBytesSent) {
    fbb_.AddElement<uint64_t>(Stats::VT_RTPBYTESSENT, rtpBytesSent, 0);
  }
  void add_rtpSendBitrate(uint32_t rtpSendBitrate) {
    fbb_.AddElement<uint32_t>(Stats::VT_RTPSENDBITRATE, rtpSendBitrate, 0);
  }
  void add_rtxBytesReceived(uint64_t rtxBytesReceived) {
    fbb_.AddElement<uint64_t>(Stats::VT_RTXBYTESRECEIVED, rtxBytesReceived, 0);
  }
  void add_rtxRecvBitrate(uint32_t rtxRecvBitrate) {
    fbb_.AddElement<uint32_t>(Stats::VT_RTXRECVBITRATE, rtxRecvBitrate, 0);
  }
  void add_rtxBytesSent(uint64_t rtxBytesSent) {
    fbb_.AddElement<uint64_t>(Stats::VT_RTXBYTESSENT, rtxBytesSent, 0);
  }
  void add_rtxSendBitrate(uint32_t rtxSendBitrate) {
    fbb_.AddElement<uint32_t>(Stats::VT_RTXSENDBITRATE, rtxSendBitrate, 0);
  }
  void add_probationBytesSent(uint64_t probationBytesSent) {
    fbb_.AddElement<uint64_t>(Stats::VT_PROBATIONBYTESSENT, probationBytesSent, 0);
  }
  void add_probationSendBitrate(uint32_t probationSendBitrate) {
    fbb_.AddElement<uint32_t>(Stats::VT_PROBATIONSENDBITRATE, probationSendBitrate, 0);
  }
  void add_availableOutgoingBitrate(uint32_t availableOutgoingBitrate) {
    fbb_.AddElement<uint32_t>(Stats::VT_AVAILABLEOUTGOINGBITRATE, availableOutgoingBitrate);
  }
  void add_availableIncomingBitrate(uint32_t availableIncomingBitrate) {
    fbb_.AddElement<uint32_t>(Stats::VT_AVAILABLEINCOMINGBITRATE, availableIncomingBitrate);
  }
  void add_maxIncomingBitrate(uint32_t maxIncomingBitrate) {
    fbb_.AddElement<uint32_t>(Stats::VT_MAXINCOMINGBITRATE, maxIncomingBitrate, 0);
  }
  void add_maxOutgoingBitrate(uint32_t maxOutgoingBitrate) {
    fbb_.AddElement<uint32_t>(Stats::VT_MAXOUTGOINGBITRATE, maxOutgoingBitrate, 0);
  }
  void add_minOutgoingBitrate(uint32_t minOutgoingBitrate) {
    fbb_.AddElement<uint32_t>(Stats::VT_MINOUTGOINGBITRATE, minOutgoingBitrate, 0);
  }
  void add_rtpPacketLossReceived(double rtpPacketLossReceived) {
    fbb_.AddElement<double>(Stats::VT_RTPPACKETLOSSRECEIVED, rtpPacketLossReceived);
  }
  void add_rtpPacketLossSent(double rtpPacketLossSent) {
    fbb_.AddElement<double>(Stats::VT_RTPPACKETLOSSSENT, rtpPacketLossSent);
  }
  explicit StatsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Stats> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Stats>(end);
    fbb_.Required(o, Stats::VT_TRANSPORTID);
    return o;
  }
};

inline ::flatbuffers::Offset<Stats> CreateStats(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> transportId = 0,
    uint64_t timestamp = 0,
    ::flatbuffers::Optional<FBS::SctpAssociation::SctpState> sctpState = ::flatbuffers::nullopt,
    uint64_t bytesReceived = 0,
    uint32_t recvBitrate = 0,
    uint64_t bytesSent = 0,
    uint32_t sendBitrate = 0,
    uint64_t rtpBytesReceived = 0,
    uint32_t rtpRecvBitrate = 0,
    uint64_t rtpBytesSent = 0,
    uint32_t rtpSendBitrate = 0,
    uint64_t rtxBytesReceived = 0,
    uint32_t rtxRecvBitrate = 0,
    uint64_t rtxBytesSent = 0,
    uint32_t rtxSendBitrate = 0,
    uint64_t probationBytesSent = 0,
    uint32_t probationSendBitrate = 0,
    ::flatbuffers::Optional<uint32_t> availableOutgoingBitrate = ::flatbuffers::nullopt,
    ::flatbuffers::Optional<uint32_t> availableIncomingBitrate = ::flatbuffers::nullopt,
    uint32_t maxIncomingBitrate = 0,
    uint32_t maxOutgoingBitrate = 0,
    uint32_t minOutgoingBitrate = 0,
    ::flatbuffers::Optional<double> rtpPacketLossReceived = ::flatbuffers::nullopt,
    ::flatbuffers::Optional<double> rtpPacketLossSent = ::flatbuffers::nullopt) {
  StatsBuilder builder_(_fbb);
  if(rtpPacketLossSent) { builder_.add_rtpPacketLossSent(*rtpPacketLossSent); }
  if(rtpPacketLossReceived) { builder_.add_rtpPacketLossReceived(*rtpPacketLossReceived); }
  builder_.add_probationBytesSent(probationBytesSent);
  builder_.add_rtxBytesSent(rtxBytesSent);
  builder_.add_rtxBytesReceived(rtxBytesReceived);
  builder_.add_rtpBytesSent(rtpBytesSent);
  builder_.add_rtpBytesReceived(rtpBytesReceived);
  builder_.add_bytesSent(bytesSent);
  builder_.add_bytesReceived(bytesReceived);
  builder_.add_timestamp(timestamp);
  builder_.add_minOutgoingBitrate(minOutgoingBitrate);
  builder_.add_maxOutgoingBitrate(maxOutgoingBitrate);
  builder_.add_maxIncomingBitrate(maxIncomingBitrate);
  if(availableIncomingBitrate) { builder_.add_availableIncomingBitrate(*availableIncomingBitrate); }
  if(availableOutgoingBitrate) { builder_.add_availableOutgoingBitrate(*availableOutgoingBitrate); }
  builder_.add_probationSendBitrate(probationSendBitrate);
  builder_.add_rtxSendBitrate(rtxSendBitrate);
  builder_.add_rtxRecvBitrate(rtxRecvBitrate);
  builder_.add_rtpSendBitrate(rtpSendBitrate);
  builder_.add_rtpRecvBitrate(rtpRecvBitrate);
  builder_.add_sendBitrate(sendBitrate);
  builder_.add_recvBitrate(recvBitrate);
  builder_.add_transportId(transportId);
  if(sctpState) { builder_.add_sctpState(*sctpState); }
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Stats> CreateStatsDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *transportId = nullptr,
    uint64_t timestamp = 0,
    ::flatbuffers::Optional<FBS::SctpAssociation::SctpState> sctpState = ::flatbuffers::nullopt,
    uint64_t bytesReceived = 0,
    uint32_t recvBitrate = 0,
    uint64_t bytesSent = 0,
    uint32_t sendBitrate = 0,
    uint64_t rtpBytesReceived = 0,
    uint32_t rtpRecvBitrate = 0,
    uint64_t rtpBytesSent = 0,
    uint32_t rtpSendBitrate = 0,
    uint64_t rtxBytesReceived = 0,
    uint32_t rtxRecvBitrate = 0,
    uint64_t rtxBytesSent = 0,
    uint32_t rtxSendBitrate = 0,
    uint64_t probationBytesSent = 0,
    uint32_t probationSendBitrate = 0,
    ::flatbuffers::Optional<uint32_t> availableOutgoingBitrate = ::flatbuffers::nullopt,
    ::flatbuffers::Optional<uint32_t> availableIncomingBitrate = ::flatbuffers::nullopt,
    uint32_t maxIncomingBitrate = 0,
    uint32_t maxOutgoingBitrate = 0,
    uint32_t minOutgoingBitrate = 0,
    ::flatbuffers::Optional<double> rtpPacketLossReceived = ::flatbuffers::nullopt,
    ::flatbuffers::Optional<double> rtpPacketLossSent = ::flatbuffers::nullopt) {
  auto transportId__ = transportId ? _fbb.CreateString(transportId) : 0;
  return FBS::Transport::CreateStats(
      _fbb,
      transportId__,
      timestamp,
      sctpState,
      bytesReceived,
      recvBitrate,
      bytesSent,
      sendBitrate,
      rtpBytesReceived,
      rtpRecvBitrate,
      rtpBytesSent,
      rtpSendBitrate,
      rtxBytesReceived,
      rtxRecvBitrate,
      rtxBytesSent,
      rtxSendBitrate,
      probationBytesSent,
      probationSendBitrate,
      availableOutgoingBitrate,
      availableIncomingBitrate,
      maxIncomingBitrate,
      maxOutgoingBitrate,
      minOutgoingBitrate,
      rtpPacketLossReceived,
      rtpPacketLossSent);
}

struct SetMaxIncomingBitrateRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SetMaxIncomingBitrateRequestBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SetMaxIncomingBitrateRequestTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MAXINCOMINGBITRATE = 4
  };
  uint32_t maxIncomingBitrate() const {
    return GetField<uint32_t>(VT_MAXINCOMINGBITRATE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_MAXINCOMINGBITRATE, 4) &&
           verifier.EndTable();
  }
};

struct SetMaxIncomingBitrateRequestBuilder {
  typedef SetMaxIncomingBitrateRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_maxIncomingBitrate(uint32_t maxIncomingBitrate) {
    fbb_.AddElement<uint32_t>(SetMaxIncomingBitrateRequest::VT_MAXINCOMINGBITRATE, maxIncomingBitrate, 0);
  }
  explicit SetMaxIncomingBitrateRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SetMaxIncomingBitrateRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SetMaxIncomingBitrateRequest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SetMaxIncomingBitrateRequest> CreateSetMaxIncomingBitrateRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t maxIncomingBitrate = 0) {
  SetMaxIncomingBitrateRequestBuilder builder_(_fbb);
  builder_.add_maxIncomingBitrate(maxIncomingBitrate);
  return builder_.Finish();
}

struct SetMaxOutgoingBitrateRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SetMaxOutgoingBitrateRequestBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SetMaxOutgoingBitrateRequestTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MAXOUTGOINGBITRATE = 4
  };
  uint32_t maxOutgoingBitrate() const {
    return GetField<uint32_t>(VT_MAXOUTGOINGBITRATE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_MAXOUTGOINGBITRATE, 4) &&
           verifier.EndTable();
  }
};

struct SetMaxOutgoingBitrateRequestBuilder {
  typedef SetMaxOutgoingBitrateRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_maxOutgoingBitrate(uint32_t maxOutgoingBitrate) {
    fbb_.AddElement<uint32_t>(SetMaxOutgoingBitrateRequest::VT_MAXOUTGOINGBITRATE, maxOutgoingBitrate, 0);
  }
  explicit SetMaxOutgoingBitrateRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SetMaxOutgoingBitrateRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SetMaxOutgoingBitrateRequest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SetMaxOutgoingBitrateRequest> CreateSetMaxOutgoingBitrateRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t maxOutgoingBitrate = 0) {
  SetMaxOutgoingBitrateRequestBuilder builder_(_fbb);
  builder_.add_maxOutgoingBitrate(maxOutgoingBitrate);
  return builder_.Finish();
}

struct SetMinOutgoingBitrateRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SetMinOutgoingBitrateRequestBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SetMinOutgoingBitrateRequestTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MINOUTGOINGBITRATE = 4
  };
  uint32_t minOutgoingBitrate() const {
    return GetField<uint32_t>(VT_MINOUTGOINGBITRATE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_MINOUTGOINGBITRATE, 4) &&
           verifier.EndTable();
  }
};

struct SetMinOutgoingBitrateRequestBuilder {
  typedef SetMinOutgoingBitrateRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_minOutgoingBitrate(uint32_t minOutgoingBitrate) {
    fbb_.AddElement<uint32_t>(SetMinOutgoingBitrateRequest::VT_MINOUTGOINGBITRATE, minOutgoingBitrate, 0);
  }
  explicit SetMinOutgoingBitrateRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SetMinOutgoingBitrateRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SetMinOutgoingBitrateRequest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SetMinOutgoingBitrateRequest> CreateSetMinOutgoingBitrateRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t minOutgoingBitrate = 0) {
  SetMinOutgoingBitrateRequestBuilder builder_(_fbb);
  builder_.add_minOutgoingBitrate(minOutgoingBitrate);
  return builder_.Finish();
}

struct EnableTraceEventRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef EnableTraceEventRequestBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return EnableTraceEventRequestTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_EVENTS = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *events() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_EVENTS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_EVENTS) &&
           verifier.VerifyVector(events()) &&
           verifier.VerifyVectorOfStrings(events()) &&
           verifier.EndTable();
  }
};

struct EnableTraceEventRequestBuilder {
  typedef EnableTraceEventRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_events(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> events) {
    fbb_.AddOffset(EnableTraceEventRequest::VT_EVENTS, events);
  }
  explicit EnableTraceEventRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<EnableTraceEventRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<EnableTraceEventRequest>(end);
    fbb_.Required(o, EnableTraceEventRequest::VT_EVENTS);
    return o;
  }
};

inline ::flatbuffers::Offset<EnableTraceEventRequest> CreateEnableTraceEventRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> events = 0) {
  EnableTraceEventRequestBuilder builder_(_fbb);
  builder_.add_events(events);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<EnableTraceEventRequest> CreateEnableTraceEventRequestDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *events = nullptr) {
  auto events__ = events ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*events) : 0;
  return FBS::Transport::CreateEnableTraceEventRequest(
      _fbb,
      events__);
}

struct CloseProducerRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CloseProducerRequestBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return CloseProducerRequestTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PRODUCERID = 4
  };
  const ::flatbuffers::String *producerId() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PRODUCERID);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_PRODUCERID) &&
           verifier.VerifyString(producerId()) &&
           verifier.EndTable();
  }
};

struct CloseProducerRequestBuilder {
  typedef CloseProducerRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_producerId(::flatbuffers::Offset<::flatbuffers::String> producerId) {
    fbb_.AddOffset(CloseProducerRequest::VT_PRODUCERID, producerId);
  }
  explicit CloseProducerRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CloseProducerRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CloseProducerRequest>(end);
    fbb_.Required(o, CloseProducerRequest::VT_PRODUCERID);
    return o;
  }
};

inline ::flatbuffers::Offset<CloseProducerRequest> CreateCloseProducerRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> producerId = 0) {
  CloseProducerRequestBuilder builder_(_fbb);
  builder_.add_producerId(producerId);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<CloseProducerRequest> CreateCloseProducerRequestDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *producerId = nullptr) {
  auto producerId__ = producerId ? _fbb.CreateString(producerId) : 0;
  return FBS::Transport::CreateCloseProducerRequest(
      _fbb,
      producerId__);
}

struct CloseConsumerRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CloseConsumerRequestBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return CloseConsumerRequestTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CONSUMERID = 4
  };
  const ::flatbuffers::String *consumerId() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CONSUMERID);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_CONSUMERID) &&
           verifier.VerifyString(consumerId()) &&
           verifier.EndTable();
  }
};

struct CloseConsumerRequestBuilder {
  typedef CloseConsumerRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_consumerId(::flatbuffers::Offset<::flatbuffers::String> consumerId) {
    fbb_.AddOffset(CloseConsumerRequest::VT_CONSUMERID, consumerId);
  }
  explicit CloseConsumerRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CloseConsumerRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CloseConsumerRequest>(end);
    fbb_.Required(o, CloseConsumerRequest::VT_CONSUMERID);
    return o;
  }
};

inline ::flatbuffers::Offset<CloseConsumerRequest> CreateCloseConsumerRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> consumerId = 0) {
  CloseConsumerRequestBuilder builder_(_fbb);
  builder_.add_consumerId(consumerId);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<CloseConsumerRequest> CreateCloseConsumerRequestDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *consumerId = nullptr) {
  auto consumerId__ = consumerId ? _fbb.CreateString(consumerId) : 0;
  return FBS::Transport::CreateCloseConsumerRequest(
      _fbb,
      consumerId__);
}

struct CloseDataProducerRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CloseDataProducerRequestBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return CloseDataProducerRequestTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATAPRODUCERID = 4
  };
  const ::flatbuffers::String *dataProducerId() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DATAPRODUCERID);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_DATAPRODUCERID) &&
           verifier.VerifyString(dataProducerId()) &&
           verifier.EndTable();
  }
};

struct CloseDataProducerRequestBuilder {
  typedef CloseDataProducerRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_dataProducerId(::flatbuffers::Offset<::flatbuffers::String> dataProducerId) {
    fbb_.AddOffset(CloseDataProducerRequest::VT_DATAPRODUCERID, dataProducerId);
  }
  explicit CloseDataProducerRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CloseDataProducerRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CloseDataProducerRequest>(end);
    fbb_.Required(o, CloseDataProducerRequest::VT_DATAPRODUCERID);
    return o;
  }
};

inline ::flatbuffers::Offset<CloseDataProducerRequest> CreateCloseDataProducerRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> dataProducerId = 0) {
  CloseDataProducerRequestBuilder builder_(_fbb);
  builder_.add_dataProducerId(dataProducerId);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<CloseDataProducerRequest> CreateCloseDataProducerRequestDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *dataProducerId = nullptr) {
  auto dataProducerId__ = dataProducerId ? _fbb.CreateString(dataProducerId) : 0;
  return FBS::Transport::CreateCloseDataProducerRequest(
      _fbb,
      dataProducerId__);
}

struct CloseDataConsumerRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CloseDataConsumerRequestBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return CloseDataConsumerRequestTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATACONSUMERID = 4
  };
  const ::flatbuffers::String *dataConsumerId() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DATACONSUMERID);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_DATACONSUMERID) &&
           verifier.VerifyString(dataConsumerId()) &&
           verifier.EndTable();
  }
};

struct CloseDataConsumerRequestBuilder {
  typedef CloseDataConsumerRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_dataConsumerId(::flatbuffers::Offset<::flatbuffers::String> dataConsumerId) {
    fbb_.AddOffset(CloseDataConsumerRequest::VT_DATACONSUMERID, dataConsumerId);
  }
  explicit CloseDataConsumerRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CloseDataConsumerRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CloseDataConsumerRequest>(end);
    fbb_.Required(o, CloseDataConsumerRequest::VT_DATACONSUMERID);
    return o;
  }
};

inline ::flatbuffers::Offset<CloseDataConsumerRequest> CreateCloseDataConsumerRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> dataConsumerId = 0) {
  CloseDataConsumerRequestBuilder builder_(_fbb);
  builder_.add_dataConsumerId(dataConsumerId);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<CloseDataConsumerRequest> CreateCloseDataConsumerRequestDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *dataConsumerId = nullptr) {
  auto dataConsumerId__ = dataConsumerId ? _fbb.CreateString(dataConsumerId) : 0;
  return FBS::Transport::CreateCloseDataConsumerRequest(
      _fbb,
      dataConsumerId__);
}

struct SendRtcpNotification FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SendRtcpNotificationBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SendRtcpNotificationTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATA = 4
  };
  const ::flatbuffers::Vector<uint8_t> *data() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
};

struct SendRtcpNotificationBuilder {
  typedef SendRtcpNotification Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_data(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> data) {
    fbb_.AddOffset(SendRtcpNotification::VT_DATA, data);
  }
  explicit SendRtcpNotificationBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SendRtcpNotification> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SendRtcpNotification>(end);
    fbb_.Required(o, SendRtcpNotification::VT_DATA);
    return o;
  }
};

inline ::flatbuffers::Offset<SendRtcpNotification> CreateSendRtcpNotification(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> data = 0) {
  SendRtcpNotificationBuilder builder_(_fbb);
  builder_.add_data(data);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<SendRtcpNotification> CreateSendRtcpNotificationDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;
  return FBS::Transport::CreateSendRtcpNotification(
      _fbb,
      data__);
}

struct SctpStateChangeNotification FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SctpStateChangeNotificationBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SctpStateChangeNotificationTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SCTPSTATE = 4
  };
  FBS::SctpAssociation::SctpState sctpState() const {
    return static_cast<FBS::SctpAssociation::SctpState>(GetField<uint8_t>(VT_SCTPSTATE, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_SCTPSTATE, 1) &&
           verifier.EndTable();
  }
};

struct SctpStateChangeNotificationBuilder {
  typedef SctpStateChangeNotification Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_sctpState(FBS::SctpAssociation::SctpState sctpState) {
    fbb_.AddElement<uint8_t>(SctpStateChangeNotification::VT_SCTPSTATE, static_cast<uint8_t>(sctpState), 0);
  }
  explicit SctpStateChangeNotificationBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SctpStateChangeNotification> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SctpStateChangeNotification>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SctpStateChangeNotification> CreateSctpStateChangeNotification(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    FBS::SctpAssociation::SctpState sctpState = FBS::SctpAssociation::SctpState::NEW) {
  SctpStateChangeNotificationBuilder builder_(_fbb);
  builder_.add_sctpState(sctpState);
  return builder_.Finish();
}

struct BweTraceInfo FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BweTraceInfoBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return BweTraceInfoTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DESIREDBITRATE = 4,
    VT_EFFECTIVEDESIREDBITRATE = 6,
    VT_MINBITRATE = 8,
    VT_MAXBITRATE = 10,
    VT_STARTBITRATE = 12,
    VT_MAXPADDINGBITRATE = 14,
    VT_AVAILABLEBITRATE = 16,
    VT_BWETYPE = 18
  };
  uint32_t desiredBitrate() const {
    return GetField<uint32_t>(VT_DESIREDBITRATE, 0);
  }
  uint32_t effectiveDesiredBitrate() const {
    return GetField<uint32_t>(VT_EFFECTIVEDESIREDBITRATE, 0);
  }
  uint32_t minBitrate() const {
    return GetField<uint32_t>(VT_MINBITRATE, 0);
  }
  uint32_t maxBitrate() const {
    return GetField<uint32_t>(VT_MAXBITRATE, 0);
  }
  uint32_t startBitrate() const {
    return GetField<uint32_t>(VT_STARTBITRATE, 0);
  }
  uint32_t maxPaddingBitrate() const {
    return GetField<uint32_t>(VT_MAXPADDINGBITRATE, 0);
  }
  uint32_t availableBitrate() const {
    return GetField<uint32_t>(VT_AVAILABLEBITRATE, 0);
  }
  FBS::Transport::BweType bweType() const {
    return static_cast<FBS::Transport::BweType>(GetField<uint8_t>(VT_BWETYPE, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_DESIREDBITRATE, 4) &&
           VerifyField<uint32_t>(verifier, VT_EFFECTIVEDESIREDBITRATE, 4) &&
           VerifyField<uint32_t>(verifier, VT_MINBITRATE, 4) &&
           VerifyField<uint32_t>(verifier, VT_MAXBITRATE, 4) &&
           VerifyField<uint32_t>(verifier, VT_STARTBITRATE, 4) &&
           VerifyField<uint32_t>(verifier, VT_MAXPADDINGBITRATE, 4) &&
           VerifyField<uint32_t>(verifier, VT_AVAILABLEBITRATE, 4) &&
           VerifyField<uint8_t>(verifier, VT_BWETYPE, 1) &&
           verifier.EndTable();
  }
};

struct BweTraceInfoBuilder {
  typedef BweTraceInfo Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_desiredBitrate(uint32_t desiredBitrate) {
    fbb_.AddElement<uint32_t>(BweTraceInfo::VT_DESIREDBITRATE, desiredBitrate, 0);
  }
  void add_effectiveDesiredBitrate(uint32_t effectiveDesiredBitrate) {
    fbb_.AddElement<uint32_t>(BweTraceInfo::VT_EFFECTIVEDESIREDBITRATE, effectiveDesiredBitrate, 0);
  }
  void add_minBitrate(uint32_t minBitrate) {
    fbb_.AddElement<uint32_t>(BweTraceInfo::VT_MINBITRATE, minBitrate, 0);
  }
  void add_maxBitrate(uint32_t maxBitrate) {
    fbb_.AddElement<uint32_t>(BweTraceInfo::VT_MAXBITRATE, maxBitrate, 0);
  }
  void add_startBitrate(uint32_t startBitrate) {
    fbb_.AddElement<uint32_t>(BweTraceInfo::VT_STARTBITRATE, startBitrate, 0);
  }
  void add_maxPaddingBitrate(uint32_t maxPaddingBitrate) {
    fbb_.AddElement<uint32_t>(BweTraceInfo::VT_MAXPADDINGBITRATE, maxPaddingBitrate, 0);
  }
  void add_availableBitrate(uint32_t availableBitrate) {
    fbb_.AddElement<uint32_t>(BweTraceInfo::VT_AVAILABLEBITRATE, availableBitrate, 0);
  }
  void add_bweType(FBS::Transport::BweType bweType) {
    fbb_.AddElement<uint8_t>(BweTraceInfo::VT_BWETYPE, static_cast<uint8_t>(bweType), 0);
  }
  explicit BweTraceInfoBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BweTraceInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BweTraceInfo>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<BweTraceInfo> CreateBweTraceInfo(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t desiredBitrate = 0,
    uint32_t effectiveDesiredBitrate = 0,
    uint32_t minBitrate = 0,
    uint32_t maxBitrate = 0,
    uint32_t startBitrate = 0,
    uint32_t maxPaddingBitrate = 0,
    uint32_t availableBitrate = 0,
    FBS::Transport::BweType bweType = FBS::Transport::BweType::TRANSPORT_CC) {
  BweTraceInfoBuilder builder_(_fbb);
  builder_.add_availableBitrate(availableBitrate);
  builder_.add_maxPaddingBitrate(maxPaddingBitrate);
  builder_.add_startBitrate(startBitrate);
  builder_.add_maxBitrate(maxBitrate);
  builder_.add_minBitrate(minBitrate);
  builder_.add_effectiveDesiredBitrate(effectiveDesiredBitrate);
  builder_.add_desiredBitrate(desiredBitrate);
  builder_.add_bweType(bweType);
  return builder_.Finish();
}

struct TraceNotification FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TraceNotificationBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return TraceNotificationTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_TIMESTAMP = 6,
    VT_DIRECTION = 8,
    VT_INFO_TYPE = 10,
    VT_INFO = 12
  };
  FBS::Transport::TraceType type() const {
    return static_cast<FBS::Transport::TraceType>(GetField<uint8_t>(VT_TYPE, 0));
  }
  uint64_t timestamp() const {
    return GetField<uint64_t>(VT_TIMESTAMP, 0);
  }
  FBS::Transport::TraceDirection direction() const {
    return static_cast<FBS::Transport::TraceDirection>(GetField<uint8_t>(VT_DIRECTION, 0));
  }
  FBS::Transport::TraceInfo info_type() const {
    return static_cast<FBS::Transport::TraceInfo>(GetField<uint8_t>(VT_INFO_TYPE, 0));
  }
  const void *info() const {
    return GetPointer<const void *>(VT_INFO);
  }
  template<typename T> const T *info_as() const;
  const FBS::Transport::BweTraceInfo *info_as_BweTraceInfo() const {
    return info_type() == FBS::Transport::TraceInfo::BweTraceInfo ? static_cast<const FBS::Transport::BweTraceInfo *>(info()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_TYPE, 1) &&
           VerifyField<uint64_t>(verifier, VT_TIMESTAMP, 8) &&
           VerifyField<uint8_t>(verifier, VT_DIRECTION, 1) &&
           VerifyField<uint8_t>(verifier, VT_INFO_TYPE, 1) &&
           VerifyOffset(verifier, VT_INFO) &&
           VerifyTraceInfo(verifier, info(), info_type()) &&
           verifier.EndTable();
  }
};

template<> inline const FBS::Transport::BweTraceInfo *TraceNotification::info_as<FBS::Transport::BweTraceInfo>() const {
  return info_as_BweTraceInfo();
}

struct TraceNotificationBuilder {
  typedef TraceNotification Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_type(FBS::Transport::TraceType type) {
    fbb_.AddElement<uint8_t>(TraceNotification::VT_TYPE, static_cast<uint8_t>(type), 0);
  }
  void add_timestamp(uint64_t timestamp) {
    fbb_.AddElement<uint64_t>(TraceNotification::VT_TIMESTAMP, timestamp, 0);
  }
  void add_direction(FBS::Transport::TraceDirection direction) {
    fbb_.AddElement<uint8_t>(TraceNotification::VT_DIRECTION, static_cast<uint8_t>(direction), 0);
  }
  void add_info_type(FBS::Transport::TraceInfo info_type) {
    fbb_.AddElement<uint8_t>(TraceNotification::VT_INFO_TYPE, static_cast<uint8_t>(info_type), 0);
  }
  void add_info(::flatbuffers::Offset<void> info) {
    fbb_.AddOffset(TraceNotification::VT_INFO, info);
  }
  explicit TraceNotificationBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TraceNotification> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TraceNotification>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TraceNotification> CreateTraceNotification(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    FBS::Transport::TraceType type = FBS::Transport::TraceType::PROBATION,
    uint64_t timestamp = 0,
    FBS::Transport::TraceDirection direction = FBS::Transport::TraceDirection::DIRECTION_IN,
    FBS::Transport::TraceInfo info_type = FBS::Transport::TraceInfo::NONE,
    ::flatbuffers::Offset<void> info = 0) {
  TraceNotificationBuilder builder_(_fbb);
  builder_.add_timestamp(timestamp);
  builder_.add_info(info);
  builder_.add_info_type(info_type);
  builder_.add_direction(direction);
  builder_.add_type(type);
  return builder_.Finish();
}

inline bool VerifyTraceInfo(::flatbuffers::Verifier &verifier, const void *obj, TraceInfo type) {
  switch (type) {
    case TraceInfo::NONE: {
      return true;
    }
    case TraceInfo::BweTraceInfo: {
      auto ptr = reinterpret_cast<const FBS::Transport::BweTraceInfo *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyTraceInfoVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<TraceInfo> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyTraceInfo(
        verifier,  values->Get(i), types->GetEnum<TraceInfo>(i))) {
      return false;
    }
  }
  return true;
}

inline const ::flatbuffers::TypeTable *ProtocolTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_UCHAR, 0, 0 },
    { ::flatbuffers::ET_UCHAR, 0, 0 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    FBS::Transport::ProtocolTypeTable
  };
  static const int64_t values[] = { 1, 2 };
  static const char * const names[] = {
    "UDP",
    "TCP"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_ENUM, 2, type_codes, type_refs, nullptr, values, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *TraceTypeTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_UCHAR, 0, 0 },
    { ::flatbuffers::ET_UCHAR, 0, 0 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    FBS::Transport::TraceTypeTypeTable
  };
  static const char * const names[] = {
    "PROBATION",
    "BWE"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_ENUM, 2, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *TraceDirectionTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_UCHAR, 0, 0 },
    { ::flatbuffers::ET_UCHAR, 0, 0 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    FBS::Transport::TraceDirectionTypeTable
  };
  static const char * const names[] = {
    "DIRECTION_IN",
    "DIRECTION_OUT"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_ENUM, 2, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *TraceInfoTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_SEQUENCE, 0, -1 },
    { ::flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    FBS::Transport::BweTraceInfoTypeTable
  };
  static const char * const names[] = {
    "NONE",
    "BweTraceInfo"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_UNION, 2, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *BweTypeTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_UCHAR, 0, 0 },
    { ::flatbuffers::ET_UCHAR, 0, 0 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    FBS::Transport::BweTypeTypeTable
  };
  static const char * const names[] = {
    "TRANSPORT_CC",
    "REMB"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_ENUM, 2, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *ListenInfoTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_UCHAR, 0, 0 },
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_USHORT, 0, -1 },
    { ::flatbuffers::ET_UINT, 0, -1 },
    { ::flatbuffers::ET_UINT, 0, -1 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    FBS::Transport::ProtocolTypeTable
  };
  static const char * const names[] = {
    "protocol",
    "ip",
    "announcedIp",
    "port",
    "sendBufferSize",
    "recvBufferSize"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 6, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *RestartIceResponseTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_BOOL, 0, -1 }
  };
  static const char * const names[] = {
    "usernameFragment",
    "password",
    "iceLite"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 3, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *ProduceRequestTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_UCHAR, 0, 0 },
    { ::flatbuffers::ET_SEQUENCE, 0, 1 },
    { ::flatbuffers::ET_SEQUENCE, 0, 2 },
    { ::flatbuffers::ET_USHORT, 0, -1 },
    { ::flatbuffers::ET_BOOL, 0, -1 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    FBS::RtpParameters::MediaKindTypeTable,
    FBS::RtpParameters::RtpParametersTypeTable,
    FBS::RtpParameters::RtpMappingTypeTable
  };
  static const char * const names[] = {
    "producerId",
    "kind",
    "rtpParameters",
    "rtpMapping",
    "keyFrameRequestDelay",
    "paused"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 6, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *ProduceResponseTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_UCHAR, 0, 0 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    FBS::RtpParameters::TypeTypeTable
  };
  static const char * const names[] = {
    "type"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *ConsumeRequestTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_UCHAR, 0, 0 },
    { ::flatbuffers::ET_SEQUENCE, 0, 1 },
    { ::flatbuffers::ET_UCHAR, 0, 2 },
    { ::flatbuffers::ET_SEQUENCE, 1, 3 },
    { ::flatbuffers::ET_BOOL, 0, -1 },
    { ::flatbuffers::ET_SEQUENCE, 0, 4 },
    { ::flatbuffers::ET_BOOL, 0, -1 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    FBS::RtpParameters::MediaKindTypeTable,
    FBS::RtpParameters::RtpParametersTypeTable,
    FBS::RtpParameters::TypeTypeTable,
    FBS::RtpParameters::RtpEncodingParametersTypeTable,
    FBS::Consumer::ConsumerLayersTypeTable
  };
  static const char * const names[] = {
    "consumerId",
    "producerId",
    "kind",
    "rtpParameters",
    "type",
    "consumableRtpEncodings",
    "paused",
    "preferredLayers",
    "ignoreDtx"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 9, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *ConsumeResponseTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_BOOL, 0, -1 },
    { ::flatbuffers::ET_BOOL, 0, -1 },
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_SEQUENCE, 0, 1 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    FBS::Consumer::ConsumerScoreTypeTable,
    FBS::Consumer::ConsumerLayersTypeTable
  };
  static const char * const names[] = {
    "paused",
    "producerPaused",
    "score",
    "preferredLayers"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 4, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *ProduceDataRequestTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_BOOL, 0, -1 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    FBS::SctpParameters::SctpStreamParametersTypeTable
  };
  static const char * const names[] = {
    "dataProducerId",
    "type",
    "sctpStreamParameters",
    "label",
    "protocol",
    "paused"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 6, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *ConsumeDataRequestTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_BOOL, 0, -1 },
    { ::flatbuffers::ET_USHORT, 1, -1 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    FBS::SctpParameters::SctpStreamParametersTypeTable
  };
  static const char * const names[] = {
    "dataConsumerId",
    "dataProducerId",
    "type",
    "sctpStreamParameters",
    "label",
    "protocol",
    "paused",
    "subchannels"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 8, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *TupleTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_USHORT, 0, -1 },
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_USHORT, 0, -1 },
    { ::flatbuffers::ET_UCHAR, 0, 0 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    FBS::Transport::ProtocolTypeTable
  };
  static const char * const names[] = {
    "localIp",
    "localPort",
    "remoteIp",
    "remotePort",
    "protocol"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 5, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *SrtpParametersTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_STRING, 0, -1 }
  };
  static const char * const names[] = {
    "cryptoSuite",
    "keyBase64"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *RtpListenerTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_SEQUENCE, 1, 0 },
    { ::flatbuffers::ET_SEQUENCE, 1, 1 },
    { ::flatbuffers::ET_SEQUENCE, 1, 1 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    FBS::Common::Uint32StringTypeTable,
    FBS::Common::StringStringTypeTable
  };
  static const char * const names[] = {
    "ssrcTable",
    "midTable",
    "ridTable"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *SctpListenerTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_SEQUENCE, 1, 0 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    FBS::Common::Uint16StringTypeTable
  };
  static const char * const names[] = {
    "streamIdTable"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *RecvRtpHeaderExtensionsTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_UCHAR, 0, -1 },
    { ::flatbuffers::ET_UCHAR, 0, -1 },
    { ::flatbuffers::ET_UCHAR, 0, -1 },
    { ::flatbuffers::ET_UCHAR, 0, -1 },
    { ::flatbuffers::ET_UCHAR, 0, -1 }
  };
  static const char * const names[] = {
    "mid",
    "rid",
    "rrid",
    "absSendTime",
    "transportWideCc01"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 5, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *OptionsTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_BOOL, 0, -1 },
    { ::flatbuffers::ET_UINT, 0, -1 },
    { ::flatbuffers::ET_UINT, 0, -1 },
    { ::flatbuffers::ET_BOOL, 0, -1 },
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, -1 },
    { ::flatbuffers::ET_UINT, 0, -1 },
    { ::flatbuffers::ET_BOOL, 0, -1 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    FBS::SctpParameters::NumSctpStreamsTypeTable
  };
  static const char * const names[] = {
    "direct",
    "maxMessageSize",
    "initialAvailableOutgoingBitrate",
    "enableSctp",
    "numSctpStreams",
    "maxSctpMessageSize",
    "sctpSendBufferSize",
    "isDataChannel"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 8, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *DumpTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_BOOL, 0, -1 },
    { ::flatbuffers::ET_STRING, 1, -1 },
    { ::flatbuffers::ET_STRING, 1, -1 },
    { ::flatbuffers::ET_SEQUENCE, 1, 0 },
    { ::flatbuffers::ET_SEQUENCE, 1, 0 },
    { ::flatbuffers::ET_STRING, 1, -1 },
    { ::flatbuffers::ET_STRING, 1, -1 },
    { ::flatbuffers::ET_SEQUENCE, 0, 1 },
    { ::flatbuffers::ET_SEQUENCE, 0, 2 },
    { ::flatbuffers::ET_UINT, 0, -1 },
    { ::flatbuffers::ET_SEQUENCE, 0, 3 },
    { ::flatbuffers::ET_UCHAR, 0, 4 },
    { ::flatbuffers::ET_SEQUENCE, 0, 5 },
    { ::flatbuffers::ET_STRING, 1, -1 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    FBS::Common::Uint32StringTypeTable,
    FBS::Transport::RecvRtpHeaderExtensionsTypeTable,
    FBS::Transport::RtpListenerTypeTable,
    FBS::SctpParameters::SctpParametersTypeTable,
    FBS::SctpAssociation::SctpStateTypeTable,
    FBS::Transport::SctpListenerTypeTable
  };
  static const char * const names[] = {
    "id",
    "direct",
    "producerIds",
    "consumerIds",
    "mapSsrcConsumerId",
    "mapRtxSsrcConsumerId",
    "dataProducerIds",
    "dataConsumerIds",
    "recvRtpHeaderExtensions",
    "rtpListener",
    "maxMessageSize",
    "sctpParameters",
    "sctpState",
    "sctpListener",
    "traceEventTypes"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 15, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *StatsTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_ULONG, 0, -1 },
    { ::flatbuffers::ET_UCHAR, 0, 0 },
    { ::flatbuffers::ET_ULONG, 0, -1 },
    { ::flatbuffers::ET_UINT, 0, -1 },
    { ::flatbuffers::ET_ULONG, 0, -1 },
    { ::flatbuffers::ET_UINT, 0, -1 },
    { ::flatbuffers::ET_ULONG, 0, -1 },
    { ::flatbuffers::ET_UINT, 0, -1 },
    { ::flatbuffers::ET_ULONG, 0, -1 },
    { ::flatbuffers::ET_UINT, 0, -1 },
    { ::flatbuffers::ET_ULONG, 0, -1 },
    { ::flatbuffers::ET_UINT, 0, -1 },
    { ::flatbuffers::ET_ULONG, 0, -1 },
    { ::flatbuffers::ET_UINT, 0, -1 },
    { ::flatbuffers::ET_ULONG, 0, -1 },
    { ::flatbuffers::ET_UINT, 0, -1 },
    { ::flatbuffers::ET_UINT, 0, -1 },
    { ::flatbuffers::ET_UINT, 0, -1 },
    { ::flatbuffers::ET_UINT, 0, -1 },
    { ::flatbuffers::ET_UINT, 0, -1 },
    { ::flatbuffers::ET_UINT, 0, -1 },
    { ::flatbuffers::ET_DOUBLE, 0, -1 },
    { ::flatbuffers::ET_DOUBLE, 0, -1 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    FBS::SctpAssociation::SctpStateTypeTable
  };
  static const char * const names[] = {
    "transportId",
    "timestamp",
    "sctpState",
    "bytesReceived",
    "recvBitrate",
    "bytesSent",
    "sendBitrate",
    "rtpBytesReceived",
    "rtpRecvBitrate",
    "rtpBytesSent",
    "rtpSendBitrate",
    "rtxBytesReceived",
    "rtxRecvBitrate",
    "rtxBytesSent",
    "rtxSendBitrate",
    "probationBytesSent",
    "probationSendBitrate",
    "availableOutgoingBitrate",
    "availableIncomingBitrate",
    "maxIncomingBitrate",
    "maxOutgoingBitrate",
    "minOutgoingBitrate",
    "rtpPacketLossReceived",
    "rtpPacketLossSent"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 24, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *SetMaxIncomingBitrateRequestTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_UINT, 0, -1 }
  };
  static const char * const names[] = {
    "maxIncomingBitrate"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *SetMaxOutgoingBitrateRequestTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_UINT, 0, -1 }
  };
  static const char * const names[] = {
    "maxOutgoingBitrate"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *SetMinOutgoingBitrateRequestTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_UINT, 0, -1 }
  };
  static const char * const names[] = {
    "minOutgoingBitrate"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *EnableTraceEventRequestTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_STRING, 1, -1 }
  };
  static const char * const names[] = {
    "events"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *CloseProducerRequestTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_STRING, 0, -1 }
  };
  static const char * const names[] = {
    "producerId"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *CloseConsumerRequestTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_STRING, 0, -1 }
  };
  static const char * const names[] = {
    "consumerId"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *CloseDataProducerRequestTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_STRING, 0, -1 }
  };
  static const char * const names[] = {
    "dataProducerId"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *CloseDataConsumerRequestTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_STRING, 0, -1 }
  };
  static const char * const names[] = {
    "dataConsumerId"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *SendRtcpNotificationTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_UCHAR, 1, -1 }
  };
  static const char * const names[] = {
    "data"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *SctpStateChangeNotificationTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_UCHAR, 0, 0 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    FBS::SctpAssociation::SctpStateTypeTable
  };
  static const char * const names[] = {
    "sctpState"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *BweTraceInfoTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_UINT, 0, -1 },
    { ::flatbuffers::ET_UINT, 0, -1 },
    { ::flatbuffers::ET_UINT, 0, -1 },
    { ::flatbuffers::ET_UINT, 0, -1 },
    { ::flatbuffers::ET_UINT, 0, -1 },
    { ::flatbuffers::ET_UINT, 0, -1 },
    { ::flatbuffers::ET_UINT, 0, -1 },
    { ::flatbuffers::ET_UCHAR, 0, 0 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    FBS::Transport::BweTypeTypeTable
  };
  static const char * const names[] = {
    "desiredBitrate",
    "effectiveDesiredBitrate",
    "minBitrate",
    "maxBitrate",
    "startBitrate",
    "maxPaddingBitrate",
    "availableBitrate",
    "bweType"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 8, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *TraceNotificationTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_UCHAR, 0, 0 },
    { ::flatbuffers::ET_ULONG, 0, -1 },
    { ::flatbuffers::ET_UCHAR, 0, 1 },
    { ::flatbuffers::ET_UTYPE, 0, 2 },
    { ::flatbuffers::ET_SEQUENCE, 0, 2 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    FBS::Transport::TraceTypeTypeTable,
    FBS::Transport::TraceDirectionTypeTable,
    FBS::Transport::TraceInfoTypeTable
  };
  static const char * const names[] = {
    "type",
    "timestamp",
    "direction",
    "info_type",
    "info"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 5, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

}  // namespace Transport
}  // namespace FBS

#endif  // FLATBUFFERS_GENERATED_TRANSPORT_FBS_TRANSPORT_H_
