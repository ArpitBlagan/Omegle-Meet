// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_WEBRTCTRANSPORT_FBS_WEBRTCTRANSPORT_H_
#define FLATBUFFERS_GENERATED_WEBRTCTRANSPORT_FBS_WEBRTCTRANSPORT_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 3,
             "Non-compatible flatbuffers version included");

#include "sctpParameters_generated.h"
#include "transport_generated.h"

namespace FBS {
namespace WebRtcTransport {

struct ListenIndividual;
struct ListenIndividualBuilder;

struct ListenServer;
struct ListenServerBuilder;

struct WebRtcTransportOptions;
struct WebRtcTransportOptionsBuilder;

struct Fingerprint;
struct FingerprintBuilder;

struct DtlsParameters;
struct DtlsParametersBuilder;

struct IceParameters;
struct IceParametersBuilder;

struct IceCandidate;
struct IceCandidateBuilder;

struct ConnectRequest;
struct ConnectRequestBuilder;

struct ConnectResponse;
struct ConnectResponseBuilder;

struct DumpResponse;
struct DumpResponseBuilder;

struct GetStatsResponse;
struct GetStatsResponseBuilder;

struct IceSelectedTupleChangeNotification;
struct IceSelectedTupleChangeNotificationBuilder;

struct IceStateChangeNotification;
struct IceStateChangeNotificationBuilder;

struct DtlsStateChangeNotification;
struct DtlsStateChangeNotificationBuilder;

inline const ::flatbuffers::TypeTable *ListenIndividualTypeTable();

inline const ::flatbuffers::TypeTable *ListenServerTypeTable();

inline const ::flatbuffers::TypeTable *WebRtcTransportOptionsTypeTable();

inline const ::flatbuffers::TypeTable *FingerprintTypeTable();

inline const ::flatbuffers::TypeTable *DtlsParametersTypeTable();

inline const ::flatbuffers::TypeTable *IceParametersTypeTable();

inline const ::flatbuffers::TypeTable *IceCandidateTypeTable();

inline const ::flatbuffers::TypeTable *ConnectRequestTypeTable();

inline const ::flatbuffers::TypeTable *ConnectResponseTypeTable();

inline const ::flatbuffers::TypeTable *DumpResponseTypeTable();

inline const ::flatbuffers::TypeTable *GetStatsResponseTypeTable();

inline const ::flatbuffers::TypeTable *IceSelectedTupleChangeNotificationTypeTable();

inline const ::flatbuffers::TypeTable *IceStateChangeNotificationTypeTable();

inline const ::flatbuffers::TypeTable *DtlsStateChangeNotificationTypeTable();

enum class Listen : uint8_t {
  NONE = 0,
  ListenIndividual = 1,
  ListenServer = 2,
  MIN = NONE,
  MAX = ListenServer
};

inline const Listen (&EnumValuesListen())[3] {
  static const Listen values[] = {
    Listen::NONE,
    Listen::ListenIndividual,
    Listen::ListenServer
  };
  return values;
}

inline const char * const *EnumNamesListen() {
  static const char * const names[4] = {
    "NONE",
    "ListenIndividual",
    "ListenServer",
    nullptr
  };
  return names;
}

inline const char *EnumNameListen(Listen e) {
  if (::flatbuffers::IsOutRange(e, Listen::NONE, Listen::ListenServer)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesListen()[index];
}

template<typename T> struct ListenTraits {
  static const Listen enum_value = Listen::NONE;
};

template<> struct ListenTraits<FBS::WebRtcTransport::ListenIndividual> {
  static const Listen enum_value = Listen::ListenIndividual;
};

template<> struct ListenTraits<FBS::WebRtcTransport::ListenServer> {
  static const Listen enum_value = Listen::ListenServer;
};

bool VerifyListen(::flatbuffers::Verifier &verifier, const void *obj, Listen type);
bool VerifyListenVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<Listen> *types);

enum class IceState : uint8_t {
  NEW = 0,
  CONNECTED = 1,
  COMPLETED = 2,
  DISCONNECTED = 3,
  CLOSED = 4,
  MIN = NEW,
  MAX = CLOSED
};

inline const IceState (&EnumValuesIceState())[5] {
  static const IceState values[] = {
    IceState::NEW,
    IceState::CONNECTED,
    IceState::COMPLETED,
    IceState::DISCONNECTED,
    IceState::CLOSED
  };
  return values;
}

inline const char * const *EnumNamesIceState() {
  static const char * const names[6] = {
    "NEW",
    "CONNECTED",
    "COMPLETED",
    "DISCONNECTED",
    "CLOSED",
    nullptr
  };
  return names;
}

inline const char *EnumNameIceState(IceState e) {
  if (::flatbuffers::IsOutRange(e, IceState::NEW, IceState::CLOSED)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesIceState()[index];
}

enum class DtlsState : uint8_t {
  NEW = 0,
  CONNECTING = 1,
  CONNECTED = 2,
  FAILED = 3,
  CLOSED = 4,
  MIN = NEW,
  MAX = CLOSED
};

inline const DtlsState (&EnumValuesDtlsState())[5] {
  static const DtlsState values[] = {
    DtlsState::NEW,
    DtlsState::CONNECTING,
    DtlsState::CONNECTED,
    DtlsState::FAILED,
    DtlsState::CLOSED
  };
  return values;
}

inline const char * const *EnumNamesDtlsState() {
  static const char * const names[6] = {
    "NEW",
    "CONNECTING",
    "CONNECTED",
    "FAILED",
    "CLOSED",
    nullptr
  };
  return names;
}

inline const char *EnumNameDtlsState(DtlsState e) {
  if (::flatbuffers::IsOutRange(e, DtlsState::NEW, DtlsState::CLOSED)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesDtlsState()[index];
}

struct ListenIndividual FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ListenIndividualBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ListenIndividualTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LISTENINFOS = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<FBS::Transport::ListenInfo>> *listenInfos() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<FBS::Transport::ListenInfo>> *>(VT_LISTENINFOS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_LISTENINFOS) &&
           verifier.VerifyVector(listenInfos()) &&
           verifier.VerifyVectorOfTables(listenInfos()) &&
           verifier.EndTable();
  }
};

struct ListenIndividualBuilder {
  typedef ListenIndividual Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_listenInfos(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<FBS::Transport::ListenInfo>>> listenInfos) {
    fbb_.AddOffset(ListenIndividual::VT_LISTENINFOS, listenInfos);
  }
  explicit ListenIndividualBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ListenIndividual> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ListenIndividual>(end);
    fbb_.Required(o, ListenIndividual::VT_LISTENINFOS);
    return o;
  }
};

inline ::flatbuffers::Offset<ListenIndividual> CreateListenIndividual(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<FBS::Transport::ListenInfo>>> listenInfos = 0) {
  ListenIndividualBuilder builder_(_fbb);
  builder_.add_listenInfos(listenInfos);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ListenIndividual> CreateListenIndividualDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<FBS::Transport::ListenInfo>> *listenInfos = nullptr) {
  auto listenInfos__ = listenInfos ? _fbb.CreateVector<::flatbuffers::Offset<FBS::Transport::ListenInfo>>(*listenInfos) : 0;
  return FBS::WebRtcTransport::CreateListenIndividual(
      _fbb,
      listenInfos__);
}

struct ListenServer FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ListenServerBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ListenServerTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_WEBRTCSERVERID = 4
  };
  const ::flatbuffers::String *webRtcServerId() const {
    return GetPointer<const ::flatbuffers::String *>(VT_WEBRTCSERVERID);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_WEBRTCSERVERID) &&
           verifier.VerifyString(webRtcServerId()) &&
           verifier.EndTable();
  }
};

struct ListenServerBuilder {
  typedef ListenServer Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_webRtcServerId(::flatbuffers::Offset<::flatbuffers::String> webRtcServerId) {
    fbb_.AddOffset(ListenServer::VT_WEBRTCSERVERID, webRtcServerId);
  }
  explicit ListenServerBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ListenServer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ListenServer>(end);
    fbb_.Required(o, ListenServer::VT_WEBRTCSERVERID);
    return o;
  }
};

inline ::flatbuffers::Offset<ListenServer> CreateListenServer(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> webRtcServerId = 0) {
  ListenServerBuilder builder_(_fbb);
  builder_.add_webRtcServerId(webRtcServerId);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ListenServer> CreateListenServerDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *webRtcServerId = nullptr) {
  auto webRtcServerId__ = webRtcServerId ? _fbb.CreateString(webRtcServerId) : 0;
  return FBS::WebRtcTransport::CreateListenServer(
      _fbb,
      webRtcServerId__);
}

struct WebRtcTransportOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef WebRtcTransportOptionsBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return WebRtcTransportOptionsTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BASE = 4,
    VT_LISTEN_TYPE = 6,
    VT_LISTEN = 8
  };
  const FBS::Transport::Options *base() const {
    return GetPointer<const FBS::Transport::Options *>(VT_BASE);
  }
  FBS::WebRtcTransport::Listen listen_type() const {
    return static_cast<FBS::WebRtcTransport::Listen>(GetField<uint8_t>(VT_LISTEN_TYPE, 0));
  }
  const void *listen() const {
    return GetPointer<const void *>(VT_LISTEN);
  }
  template<typename T> const T *listen_as() const;
  const FBS::WebRtcTransport::ListenIndividual *listen_as_ListenIndividual() const {
    return listen_type() == FBS::WebRtcTransport::Listen::ListenIndividual ? static_cast<const FBS::WebRtcTransport::ListenIndividual *>(listen()) : nullptr;
  }
  const FBS::WebRtcTransport::ListenServer *listen_as_ListenServer() const {
    return listen_type() == FBS::WebRtcTransport::Listen::ListenServer ? static_cast<const FBS::WebRtcTransport::ListenServer *>(listen()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_BASE) &&
           verifier.VerifyTable(base()) &&
           VerifyField<uint8_t>(verifier, VT_LISTEN_TYPE, 1) &&
           VerifyOffsetRequired(verifier, VT_LISTEN) &&
           VerifyListen(verifier, listen(), listen_type()) &&
           verifier.EndTable();
  }
};

template<> inline const FBS::WebRtcTransport::ListenIndividual *WebRtcTransportOptions::listen_as<FBS::WebRtcTransport::ListenIndividual>() const {
  return listen_as_ListenIndividual();
}

template<> inline const FBS::WebRtcTransport::ListenServer *WebRtcTransportOptions::listen_as<FBS::WebRtcTransport::ListenServer>() const {
  return listen_as_ListenServer();
}

struct WebRtcTransportOptionsBuilder {
  typedef WebRtcTransportOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_base(::flatbuffers::Offset<FBS::Transport::Options> base) {
    fbb_.AddOffset(WebRtcTransportOptions::VT_BASE, base);
  }
  void add_listen_type(FBS::WebRtcTransport::Listen listen_type) {
    fbb_.AddElement<uint8_t>(WebRtcTransportOptions::VT_LISTEN_TYPE, static_cast<uint8_t>(listen_type), 0);
  }
  void add_listen(::flatbuffers::Offset<void> listen) {
    fbb_.AddOffset(WebRtcTransportOptions::VT_LISTEN, listen);
  }
  explicit WebRtcTransportOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<WebRtcTransportOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<WebRtcTransportOptions>(end);
    fbb_.Required(o, WebRtcTransportOptions::VT_BASE);
    fbb_.Required(o, WebRtcTransportOptions::VT_LISTEN);
    return o;
  }
};

inline ::flatbuffers::Offset<WebRtcTransportOptions> CreateWebRtcTransportOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<FBS::Transport::Options> base = 0,
    FBS::WebRtcTransport::Listen listen_type = FBS::WebRtcTransport::Listen::NONE,
    ::flatbuffers::Offset<void> listen = 0) {
  WebRtcTransportOptionsBuilder builder_(_fbb);
  builder_.add_listen(listen);
  builder_.add_base(base);
  builder_.add_listen_type(listen_type);
  return builder_.Finish();
}

struct Fingerprint FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FingerprintBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return FingerprintTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ALGORITHM = 4,
    VT_VALUE = 6
  };
  const ::flatbuffers::String *algorithm() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ALGORITHM);
  }
  const ::flatbuffers::String *value() const {
    return GetPointer<const ::flatbuffers::String *>(VT_VALUE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ALGORITHM) &&
           verifier.VerifyString(algorithm()) &&
           VerifyOffsetRequired(verifier, VT_VALUE) &&
           verifier.VerifyString(value()) &&
           verifier.EndTable();
  }
};

struct FingerprintBuilder {
  typedef Fingerprint Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_algorithm(::flatbuffers::Offset<::flatbuffers::String> algorithm) {
    fbb_.AddOffset(Fingerprint::VT_ALGORITHM, algorithm);
  }
  void add_value(::flatbuffers::Offset<::flatbuffers::String> value) {
    fbb_.AddOffset(Fingerprint::VT_VALUE, value);
  }
  explicit FingerprintBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Fingerprint> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Fingerprint>(end);
    fbb_.Required(o, Fingerprint::VT_ALGORITHM);
    fbb_.Required(o, Fingerprint::VT_VALUE);
    return o;
  }
};

inline ::flatbuffers::Offset<Fingerprint> CreateFingerprint(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> algorithm = 0,
    ::flatbuffers::Offset<::flatbuffers::String> value = 0) {
  FingerprintBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_algorithm(algorithm);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Fingerprint> CreateFingerprintDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *algorithm = nullptr,
    const char *value = nullptr) {
  auto algorithm__ = algorithm ? _fbb.CreateString(algorithm) : 0;
  auto value__ = value ? _fbb.CreateString(value) : 0;
  return FBS::WebRtcTransport::CreateFingerprint(
      _fbb,
      algorithm__,
      value__);
}

struct DtlsParameters FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DtlsParametersBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return DtlsParametersTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FINGERPRINTS = 4,
    VT_ROLE = 6
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<FBS::WebRtcTransport::Fingerprint>> *fingerprints() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<FBS::WebRtcTransport::Fingerprint>> *>(VT_FINGERPRINTS);
  }
  const ::flatbuffers::String *role() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ROLE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_FINGERPRINTS) &&
           verifier.VerifyVector(fingerprints()) &&
           verifier.VerifyVectorOfTables(fingerprints()) &&
           VerifyOffset(verifier, VT_ROLE) &&
           verifier.VerifyString(role()) &&
           verifier.EndTable();
  }
};

struct DtlsParametersBuilder {
  typedef DtlsParameters Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_fingerprints(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<FBS::WebRtcTransport::Fingerprint>>> fingerprints) {
    fbb_.AddOffset(DtlsParameters::VT_FINGERPRINTS, fingerprints);
  }
  void add_role(::flatbuffers::Offset<::flatbuffers::String> role) {
    fbb_.AddOffset(DtlsParameters::VT_ROLE, role);
  }
  explicit DtlsParametersBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DtlsParameters> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DtlsParameters>(end);
    fbb_.Required(o, DtlsParameters::VT_FINGERPRINTS);
    return o;
  }
};

inline ::flatbuffers::Offset<DtlsParameters> CreateDtlsParameters(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<FBS::WebRtcTransport::Fingerprint>>> fingerprints = 0,
    ::flatbuffers::Offset<::flatbuffers::String> role = 0) {
  DtlsParametersBuilder builder_(_fbb);
  builder_.add_role(role);
  builder_.add_fingerprints(fingerprints);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<DtlsParameters> CreateDtlsParametersDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<FBS::WebRtcTransport::Fingerprint>> *fingerprints = nullptr,
    const char *role = nullptr) {
  auto fingerprints__ = fingerprints ? _fbb.CreateVector<::flatbuffers::Offset<FBS::WebRtcTransport::Fingerprint>>(*fingerprints) : 0;
  auto role__ = role ? _fbb.CreateString(role) : 0;
  return FBS::WebRtcTransport::CreateDtlsParameters(
      _fbb,
      fingerprints__,
      role__);
}

struct IceParameters FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef IceParametersBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return IceParametersTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_USERNAMEFRAGMENT = 4,
    VT_PASSWORD = 6,
    VT_ICELITE = 8
  };
  const ::flatbuffers::String *usernameFragment() const {
    return GetPointer<const ::flatbuffers::String *>(VT_USERNAMEFRAGMENT);
  }
  const ::flatbuffers::String *password() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PASSWORD);
  }
  bool iceLite() const {
    return GetField<uint8_t>(VT_ICELITE, 1) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_USERNAMEFRAGMENT) &&
           verifier.VerifyString(usernameFragment()) &&
           VerifyOffsetRequired(verifier, VT_PASSWORD) &&
           verifier.VerifyString(password()) &&
           VerifyField<uint8_t>(verifier, VT_ICELITE, 1) &&
           verifier.EndTable();
  }
};

struct IceParametersBuilder {
  typedef IceParameters Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_usernameFragment(::flatbuffers::Offset<::flatbuffers::String> usernameFragment) {
    fbb_.AddOffset(IceParameters::VT_USERNAMEFRAGMENT, usernameFragment);
  }
  void add_password(::flatbuffers::Offset<::flatbuffers::String> password) {
    fbb_.AddOffset(IceParameters::VT_PASSWORD, password);
  }
  void add_iceLite(bool iceLite) {
    fbb_.AddElement<uint8_t>(IceParameters::VT_ICELITE, static_cast<uint8_t>(iceLite), 1);
  }
  explicit IceParametersBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<IceParameters> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<IceParameters>(end);
    fbb_.Required(o, IceParameters::VT_USERNAMEFRAGMENT);
    fbb_.Required(o, IceParameters::VT_PASSWORD);
    return o;
  }
};

inline ::flatbuffers::Offset<IceParameters> CreateIceParameters(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> usernameFragment = 0,
    ::flatbuffers::Offset<::flatbuffers::String> password = 0,
    bool iceLite = true) {
  IceParametersBuilder builder_(_fbb);
  builder_.add_password(password);
  builder_.add_usernameFragment(usernameFragment);
  builder_.add_iceLite(iceLite);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<IceParameters> CreateIceParametersDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *usernameFragment = nullptr,
    const char *password = nullptr,
    bool iceLite = true) {
  auto usernameFragment__ = usernameFragment ? _fbb.CreateString(usernameFragment) : 0;
  auto password__ = password ? _fbb.CreateString(password) : 0;
  return FBS::WebRtcTransport::CreateIceParameters(
      _fbb,
      usernameFragment__,
      password__,
      iceLite);
}

struct IceCandidate FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef IceCandidateBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return IceCandidateTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FOUNDATION = 4,
    VT_PRIORITY = 6,
    VT_IP = 8,
    VT_PROTOCOL = 10,
    VT_PORT = 12,
    VT_TYPE = 14,
    VT_TCPTYPE = 16
  };
  const ::flatbuffers::String *foundation() const {
    return GetPointer<const ::flatbuffers::String *>(VT_FOUNDATION);
  }
  uint32_t priority() const {
    return GetField<uint32_t>(VT_PRIORITY, 0);
  }
  const ::flatbuffers::String *ip() const {
    return GetPointer<const ::flatbuffers::String *>(VT_IP);
  }
  FBS::Transport::Protocol protocol() const {
    return static_cast<FBS::Transport::Protocol>(GetField<uint8_t>(VT_PROTOCOL, 1));
  }
  uint16_t port() const {
    return GetField<uint16_t>(VT_PORT, 0);
  }
  const ::flatbuffers::String *type() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TYPE);
  }
  const ::flatbuffers::String *tcpType() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TCPTYPE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_FOUNDATION) &&
           verifier.VerifyString(foundation()) &&
           VerifyField<uint32_t>(verifier, VT_PRIORITY, 4) &&
           VerifyOffsetRequired(verifier, VT_IP) &&
           verifier.VerifyString(ip()) &&
           VerifyField<uint8_t>(verifier, VT_PROTOCOL, 1) &&
           VerifyField<uint16_t>(verifier, VT_PORT, 2) &&
           VerifyOffset(verifier, VT_TYPE) &&
           verifier.VerifyString(type()) &&
           VerifyOffset(verifier, VT_TCPTYPE) &&
           verifier.VerifyString(tcpType()) &&
           verifier.EndTable();
  }
};

struct IceCandidateBuilder {
  typedef IceCandidate Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_foundation(::flatbuffers::Offset<::flatbuffers::String> foundation) {
    fbb_.AddOffset(IceCandidate::VT_FOUNDATION, foundation);
  }
  void add_priority(uint32_t priority) {
    fbb_.AddElement<uint32_t>(IceCandidate::VT_PRIORITY, priority, 0);
  }
  void add_ip(::flatbuffers::Offset<::flatbuffers::String> ip) {
    fbb_.AddOffset(IceCandidate::VT_IP, ip);
  }
  void add_protocol(FBS::Transport::Protocol protocol) {
    fbb_.AddElement<uint8_t>(IceCandidate::VT_PROTOCOL, static_cast<uint8_t>(protocol), 1);
  }
  void add_port(uint16_t port) {
    fbb_.AddElement<uint16_t>(IceCandidate::VT_PORT, port, 0);
  }
  void add_type(::flatbuffers::Offset<::flatbuffers::String> type) {
    fbb_.AddOffset(IceCandidate::VT_TYPE, type);
  }
  void add_tcpType(::flatbuffers::Offset<::flatbuffers::String> tcpType) {
    fbb_.AddOffset(IceCandidate::VT_TCPTYPE, tcpType);
  }
  explicit IceCandidateBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<IceCandidate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<IceCandidate>(end);
    fbb_.Required(o, IceCandidate::VT_FOUNDATION);
    fbb_.Required(o, IceCandidate::VT_IP);
    return o;
  }
};

inline ::flatbuffers::Offset<IceCandidate> CreateIceCandidate(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> foundation = 0,
    uint32_t priority = 0,
    ::flatbuffers::Offset<::flatbuffers::String> ip = 0,
    FBS::Transport::Protocol protocol = FBS::Transport::Protocol::UDP,
    uint16_t port = 0,
    ::flatbuffers::Offset<::flatbuffers::String> type = 0,
    ::flatbuffers::Offset<::flatbuffers::String> tcpType = 0) {
  IceCandidateBuilder builder_(_fbb);
  builder_.add_tcpType(tcpType);
  builder_.add_type(type);
  builder_.add_ip(ip);
  builder_.add_priority(priority);
  builder_.add_foundation(foundation);
  builder_.add_port(port);
  builder_.add_protocol(protocol);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<IceCandidate> CreateIceCandidateDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *foundation = nullptr,
    uint32_t priority = 0,
    const char *ip = nullptr,
    FBS::Transport::Protocol protocol = FBS::Transport::Protocol::UDP,
    uint16_t port = 0,
    const char *type = nullptr,
    const char *tcpType = nullptr) {
  auto foundation__ = foundation ? _fbb.CreateString(foundation) : 0;
  auto ip__ = ip ? _fbb.CreateString(ip) : 0;
  auto type__ = type ? _fbb.CreateString(type) : 0;
  auto tcpType__ = tcpType ? _fbb.CreateString(tcpType) : 0;
  return FBS::WebRtcTransport::CreateIceCandidate(
      _fbb,
      foundation__,
      priority,
      ip__,
      protocol,
      port,
      type__,
      tcpType__);
}

struct ConnectRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ConnectRequestBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ConnectRequestTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DTLSPARAMETERS = 4
  };
  const FBS::WebRtcTransport::DtlsParameters *dtlsParameters() const {
    return GetPointer<const FBS::WebRtcTransport::DtlsParameters *>(VT_DTLSPARAMETERS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_DTLSPARAMETERS) &&
           verifier.VerifyTable(dtlsParameters()) &&
           verifier.EndTable();
  }
};

struct ConnectRequestBuilder {
  typedef ConnectRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_dtlsParameters(::flatbuffers::Offset<FBS::WebRtcTransport::DtlsParameters> dtlsParameters) {
    fbb_.AddOffset(ConnectRequest::VT_DTLSPARAMETERS, dtlsParameters);
  }
  explicit ConnectRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ConnectRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ConnectRequest>(end);
    fbb_.Required(o, ConnectRequest::VT_DTLSPARAMETERS);
    return o;
  }
};

inline ::flatbuffers::Offset<ConnectRequest> CreateConnectRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<FBS::WebRtcTransport::DtlsParameters> dtlsParameters = 0) {
  ConnectRequestBuilder builder_(_fbb);
  builder_.add_dtlsParameters(dtlsParameters);
  return builder_.Finish();
}

struct ConnectResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ConnectResponseBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ConnectResponseTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DTLSLOCALROLE = 4
  };
  const ::flatbuffers::String *dtlsLocalRole() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DTLSLOCALROLE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_DTLSLOCALROLE) &&
           verifier.VerifyString(dtlsLocalRole()) &&
           verifier.EndTable();
  }
};

struct ConnectResponseBuilder {
  typedef ConnectResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_dtlsLocalRole(::flatbuffers::Offset<::flatbuffers::String> dtlsLocalRole) {
    fbb_.AddOffset(ConnectResponse::VT_DTLSLOCALROLE, dtlsLocalRole);
  }
  explicit ConnectResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ConnectResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ConnectResponse>(end);
    fbb_.Required(o, ConnectResponse::VT_DTLSLOCALROLE);
    return o;
  }
};

inline ::flatbuffers::Offset<ConnectResponse> CreateConnectResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> dtlsLocalRole = 0) {
  ConnectResponseBuilder builder_(_fbb);
  builder_.add_dtlsLocalRole(dtlsLocalRole);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ConnectResponse> CreateConnectResponseDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *dtlsLocalRole = nullptr) {
  auto dtlsLocalRole__ = dtlsLocalRole ? _fbb.CreateString(dtlsLocalRole) : 0;
  return FBS::WebRtcTransport::CreateConnectResponse(
      _fbb,
      dtlsLocalRole__);
}

struct DumpResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DumpResponseBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return DumpResponseTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BASE = 4,
    VT_ICEROLE = 6,
    VT_ICEPARAMETERS = 8,
    VT_ICECANDIDATES = 10,
    VT_ICESTATE = 12,
    VT_ICESELECTEDTUPLE = 14,
    VT_DTLSPARAMETERS = 16,
    VT_DTLSSTATE = 18
  };
  const FBS::Transport::Dump *base() const {
    return GetPointer<const FBS::Transport::Dump *>(VT_BASE);
  }
  const ::flatbuffers::String *iceRole() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ICEROLE);
  }
  const FBS::WebRtcTransport::IceParameters *iceParameters() const {
    return GetPointer<const FBS::WebRtcTransport::IceParameters *>(VT_ICEPARAMETERS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<FBS::WebRtcTransport::IceCandidate>> *iceCandidates() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<FBS::WebRtcTransport::IceCandidate>> *>(VT_ICECANDIDATES);
  }
  const ::flatbuffers::String *iceState() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ICESTATE);
  }
  const FBS::Transport::Tuple *iceSelectedTuple() const {
    return GetPointer<const FBS::Transport::Tuple *>(VT_ICESELECTEDTUPLE);
  }
  const FBS::WebRtcTransport::DtlsParameters *dtlsParameters() const {
    return GetPointer<const FBS::WebRtcTransport::DtlsParameters *>(VT_DTLSPARAMETERS);
  }
  const ::flatbuffers::String *dtlsState() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DTLSSTATE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_BASE) &&
           verifier.VerifyTable(base()) &&
           VerifyOffsetRequired(verifier, VT_ICEROLE) &&
           verifier.VerifyString(iceRole()) &&
           VerifyOffsetRequired(verifier, VT_ICEPARAMETERS) &&
           verifier.VerifyTable(iceParameters()) &&
           VerifyOffsetRequired(verifier, VT_ICECANDIDATES) &&
           verifier.VerifyVector(iceCandidates()) &&
           verifier.VerifyVectorOfTables(iceCandidates()) &&
           VerifyOffsetRequired(verifier, VT_ICESTATE) &&
           verifier.VerifyString(iceState()) &&
           VerifyOffset(verifier, VT_ICESELECTEDTUPLE) &&
           verifier.VerifyTable(iceSelectedTuple()) &&
           VerifyOffsetRequired(verifier, VT_DTLSPARAMETERS) &&
           verifier.VerifyTable(dtlsParameters()) &&
           VerifyOffsetRequired(verifier, VT_DTLSSTATE) &&
           verifier.VerifyString(dtlsState()) &&
           verifier.EndTable();
  }
};

struct DumpResponseBuilder {
  typedef DumpResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_base(::flatbuffers::Offset<FBS::Transport::Dump> base) {
    fbb_.AddOffset(DumpResponse::VT_BASE, base);
  }
  void add_iceRole(::flatbuffers::Offset<::flatbuffers::String> iceRole) {
    fbb_.AddOffset(DumpResponse::VT_ICEROLE, iceRole);
  }
  void add_iceParameters(::flatbuffers::Offset<FBS::WebRtcTransport::IceParameters> iceParameters) {
    fbb_.AddOffset(DumpResponse::VT_ICEPARAMETERS, iceParameters);
  }
  void add_iceCandidates(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<FBS::WebRtcTransport::IceCandidate>>> iceCandidates) {
    fbb_.AddOffset(DumpResponse::VT_ICECANDIDATES, iceCandidates);
  }
  void add_iceState(::flatbuffers::Offset<::flatbuffers::String> iceState) {
    fbb_.AddOffset(DumpResponse::VT_ICESTATE, iceState);
  }
  void add_iceSelectedTuple(::flatbuffers::Offset<FBS::Transport::Tuple> iceSelectedTuple) {
    fbb_.AddOffset(DumpResponse::VT_ICESELECTEDTUPLE, iceSelectedTuple);
  }
  void add_dtlsParameters(::flatbuffers::Offset<FBS::WebRtcTransport::DtlsParameters> dtlsParameters) {
    fbb_.AddOffset(DumpResponse::VT_DTLSPARAMETERS, dtlsParameters);
  }
  void add_dtlsState(::flatbuffers::Offset<::flatbuffers::String> dtlsState) {
    fbb_.AddOffset(DumpResponse::VT_DTLSSTATE, dtlsState);
  }
  explicit DumpResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DumpResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DumpResponse>(end);
    fbb_.Required(o, DumpResponse::VT_BASE);
    fbb_.Required(o, DumpResponse::VT_ICEROLE);
    fbb_.Required(o, DumpResponse::VT_ICEPARAMETERS);
    fbb_.Required(o, DumpResponse::VT_ICECANDIDATES);
    fbb_.Required(o, DumpResponse::VT_ICESTATE);
    fbb_.Required(o, DumpResponse::VT_DTLSPARAMETERS);
    fbb_.Required(o, DumpResponse::VT_DTLSSTATE);
    return o;
  }
};

inline ::flatbuffers::Offset<DumpResponse> CreateDumpResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<FBS::Transport::Dump> base = 0,
    ::flatbuffers::Offset<::flatbuffers::String> iceRole = 0,
    ::flatbuffers::Offset<FBS::WebRtcTransport::IceParameters> iceParameters = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<FBS::WebRtcTransport::IceCandidate>>> iceCandidates = 0,
    ::flatbuffers::Offset<::flatbuffers::String> iceState = 0,
    ::flatbuffers::Offset<FBS::Transport::Tuple> iceSelectedTuple = 0,
    ::flatbuffers::Offset<FBS::WebRtcTransport::DtlsParameters> dtlsParameters = 0,
    ::flatbuffers::Offset<::flatbuffers::String> dtlsState = 0) {
  DumpResponseBuilder builder_(_fbb);
  builder_.add_dtlsState(dtlsState);
  builder_.add_dtlsParameters(dtlsParameters);
  builder_.add_iceSelectedTuple(iceSelectedTuple);
  builder_.add_iceState(iceState);
  builder_.add_iceCandidates(iceCandidates);
  builder_.add_iceParameters(iceParameters);
  builder_.add_iceRole(iceRole);
  builder_.add_base(base);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<DumpResponse> CreateDumpResponseDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<FBS::Transport::Dump> base = 0,
    const char *iceRole = nullptr,
    ::flatbuffers::Offset<FBS::WebRtcTransport::IceParameters> iceParameters = 0,
    const std::vector<::flatbuffers::Offset<FBS::WebRtcTransport::IceCandidate>> *iceCandidates = nullptr,
    const char *iceState = nullptr,
    ::flatbuffers::Offset<FBS::Transport::Tuple> iceSelectedTuple = 0,
    ::flatbuffers::Offset<FBS::WebRtcTransport::DtlsParameters> dtlsParameters = 0,
    const char *dtlsState = nullptr) {
  auto iceRole__ = iceRole ? _fbb.CreateString(iceRole) : 0;
  auto iceCandidates__ = iceCandidates ? _fbb.CreateVector<::flatbuffers::Offset<FBS::WebRtcTransport::IceCandidate>>(*iceCandidates) : 0;
  auto iceState__ = iceState ? _fbb.CreateString(iceState) : 0;
  auto dtlsState__ = dtlsState ? _fbb.CreateString(dtlsState) : 0;
  return FBS::WebRtcTransport::CreateDumpResponse(
      _fbb,
      base,
      iceRole__,
      iceParameters,
      iceCandidates__,
      iceState__,
      iceSelectedTuple,
      dtlsParameters,
      dtlsState__);
}

struct GetStatsResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GetStatsResponseBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return GetStatsResponseTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BASE = 4,
    VT_ICEROLE = 6,
    VT_ICESTATE = 8,
    VT_ICESELECTEDTUPLE = 10,
    VT_DTLSSTATE = 12
  };
  const FBS::Transport::Stats *base() const {
    return GetPointer<const FBS::Transport::Stats *>(VT_BASE);
  }
  const ::flatbuffers::String *iceRole() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ICEROLE);
  }
  const ::flatbuffers::String *iceState() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ICESTATE);
  }
  const FBS::Transport::Tuple *iceSelectedTuple() const {
    return GetPointer<const FBS::Transport::Tuple *>(VT_ICESELECTEDTUPLE);
  }
  const ::flatbuffers::String *dtlsState() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DTLSSTATE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_BASE) &&
           verifier.VerifyTable(base()) &&
           VerifyOffsetRequired(verifier, VT_ICEROLE) &&
           verifier.VerifyString(iceRole()) &&
           VerifyOffsetRequired(verifier, VT_ICESTATE) &&
           verifier.VerifyString(iceState()) &&
           VerifyOffset(verifier, VT_ICESELECTEDTUPLE) &&
           verifier.VerifyTable(iceSelectedTuple()) &&
           VerifyOffsetRequired(verifier, VT_DTLSSTATE) &&
           verifier.VerifyString(dtlsState()) &&
           verifier.EndTable();
  }
};

struct GetStatsResponseBuilder {
  typedef GetStatsResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_base(::flatbuffers::Offset<FBS::Transport::Stats> base) {
    fbb_.AddOffset(GetStatsResponse::VT_BASE, base);
  }
  void add_iceRole(::flatbuffers::Offset<::flatbuffers::String> iceRole) {
    fbb_.AddOffset(GetStatsResponse::VT_ICEROLE, iceRole);
  }
  void add_iceState(::flatbuffers::Offset<::flatbuffers::String> iceState) {
    fbb_.AddOffset(GetStatsResponse::VT_ICESTATE, iceState);
  }
  void add_iceSelectedTuple(::flatbuffers::Offset<FBS::Transport::Tuple> iceSelectedTuple) {
    fbb_.AddOffset(GetStatsResponse::VT_ICESELECTEDTUPLE, iceSelectedTuple);
  }
  void add_dtlsState(::flatbuffers::Offset<::flatbuffers::String> dtlsState) {
    fbb_.AddOffset(GetStatsResponse::VT_DTLSSTATE, dtlsState);
  }
  explicit GetStatsResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GetStatsResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GetStatsResponse>(end);
    fbb_.Required(o, GetStatsResponse::VT_BASE);
    fbb_.Required(o, GetStatsResponse::VT_ICEROLE);
    fbb_.Required(o, GetStatsResponse::VT_ICESTATE);
    fbb_.Required(o, GetStatsResponse::VT_DTLSSTATE);
    return o;
  }
};

inline ::flatbuffers::Offset<GetStatsResponse> CreateGetStatsResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<FBS::Transport::Stats> base = 0,
    ::flatbuffers::Offset<::flatbuffers::String> iceRole = 0,
    ::flatbuffers::Offset<::flatbuffers::String> iceState = 0,
    ::flatbuffers::Offset<FBS::Transport::Tuple> iceSelectedTuple = 0,
    ::flatbuffers::Offset<::flatbuffers::String> dtlsState = 0) {
  GetStatsResponseBuilder builder_(_fbb);
  builder_.add_dtlsState(dtlsState);
  builder_.add_iceSelectedTuple(iceSelectedTuple);
  builder_.add_iceState(iceState);
  builder_.add_iceRole(iceRole);
  builder_.add_base(base);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<GetStatsResponse> CreateGetStatsResponseDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<FBS::Transport::Stats> base = 0,
    const char *iceRole = nullptr,
    const char *iceState = nullptr,
    ::flatbuffers::Offset<FBS::Transport::Tuple> iceSelectedTuple = 0,
    const char *dtlsState = nullptr) {
  auto iceRole__ = iceRole ? _fbb.CreateString(iceRole) : 0;
  auto iceState__ = iceState ? _fbb.CreateString(iceState) : 0;
  auto dtlsState__ = dtlsState ? _fbb.CreateString(dtlsState) : 0;
  return FBS::WebRtcTransport::CreateGetStatsResponse(
      _fbb,
      base,
      iceRole__,
      iceState__,
      iceSelectedTuple,
      dtlsState__);
}

struct IceSelectedTupleChangeNotification FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef IceSelectedTupleChangeNotificationBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return IceSelectedTupleChangeNotificationTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TUPLE = 4
  };
  const FBS::Transport::Tuple *tuple() const {
    return GetPointer<const FBS::Transport::Tuple *>(VT_TUPLE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_TUPLE) &&
           verifier.VerifyTable(tuple()) &&
           verifier.EndTable();
  }
};

struct IceSelectedTupleChangeNotificationBuilder {
  typedef IceSelectedTupleChangeNotification Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_tuple(::flatbuffers::Offset<FBS::Transport::Tuple> tuple) {
    fbb_.AddOffset(IceSelectedTupleChangeNotification::VT_TUPLE, tuple);
  }
  explicit IceSelectedTupleChangeNotificationBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<IceSelectedTupleChangeNotification> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<IceSelectedTupleChangeNotification>(end);
    fbb_.Required(o, IceSelectedTupleChangeNotification::VT_TUPLE);
    return o;
  }
};

inline ::flatbuffers::Offset<IceSelectedTupleChangeNotification> CreateIceSelectedTupleChangeNotification(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<FBS::Transport::Tuple> tuple = 0) {
  IceSelectedTupleChangeNotificationBuilder builder_(_fbb);
  builder_.add_tuple(tuple);
  return builder_.Finish();
}

struct IceStateChangeNotification FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef IceStateChangeNotificationBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return IceStateChangeNotificationTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ICESTATE = 4
  };
  FBS::WebRtcTransport::IceState iceState() const {
    return static_cast<FBS::WebRtcTransport::IceState>(GetField<uint8_t>(VT_ICESTATE, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ICESTATE, 1) &&
           verifier.EndTable();
  }
};

struct IceStateChangeNotificationBuilder {
  typedef IceStateChangeNotification Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_iceState(FBS::WebRtcTransport::IceState iceState) {
    fbb_.AddElement<uint8_t>(IceStateChangeNotification::VT_ICESTATE, static_cast<uint8_t>(iceState), 0);
  }
  explicit IceStateChangeNotificationBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<IceStateChangeNotification> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<IceStateChangeNotification>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<IceStateChangeNotification> CreateIceStateChangeNotification(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    FBS::WebRtcTransport::IceState iceState = FBS::WebRtcTransport::IceState::NEW) {
  IceStateChangeNotificationBuilder builder_(_fbb);
  builder_.add_iceState(iceState);
  return builder_.Finish();
}

struct DtlsStateChangeNotification FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DtlsStateChangeNotificationBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return DtlsStateChangeNotificationTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DTLSSTATE = 4,
    VT_REMOTECERT = 6
  };
  FBS::WebRtcTransport::DtlsState dtlsState() const {
    return static_cast<FBS::WebRtcTransport::DtlsState>(GetField<uint8_t>(VT_DTLSSTATE, 0));
  }
  const ::flatbuffers::String *remoteCert() const {
    return GetPointer<const ::flatbuffers::String *>(VT_REMOTECERT);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_DTLSSTATE, 1) &&
           VerifyOffset(verifier, VT_REMOTECERT) &&
           verifier.VerifyString(remoteCert()) &&
           verifier.EndTable();
  }
};

struct DtlsStateChangeNotificationBuilder {
  typedef DtlsStateChangeNotification Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_dtlsState(FBS::WebRtcTransport::DtlsState dtlsState) {
    fbb_.AddElement<uint8_t>(DtlsStateChangeNotification::VT_DTLSSTATE, static_cast<uint8_t>(dtlsState), 0);
  }
  void add_remoteCert(::flatbuffers::Offset<::flatbuffers::String> remoteCert) {
    fbb_.AddOffset(DtlsStateChangeNotification::VT_REMOTECERT, remoteCert);
  }
  explicit DtlsStateChangeNotificationBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DtlsStateChangeNotification> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DtlsStateChangeNotification>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<DtlsStateChangeNotification> CreateDtlsStateChangeNotification(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    FBS::WebRtcTransport::DtlsState dtlsState = FBS::WebRtcTransport::DtlsState::NEW,
    ::flatbuffers::Offset<::flatbuffers::String> remoteCert = 0) {
  DtlsStateChangeNotificationBuilder builder_(_fbb);
  builder_.add_remoteCert(remoteCert);
  builder_.add_dtlsState(dtlsState);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<DtlsStateChangeNotification> CreateDtlsStateChangeNotificationDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    FBS::WebRtcTransport::DtlsState dtlsState = FBS::WebRtcTransport::DtlsState::NEW,
    const char *remoteCert = nullptr) {
  auto remoteCert__ = remoteCert ? _fbb.CreateString(remoteCert) : 0;
  return FBS::WebRtcTransport::CreateDtlsStateChangeNotification(
      _fbb,
      dtlsState,
      remoteCert__);
}

inline bool VerifyListen(::flatbuffers::Verifier &verifier, const void *obj, Listen type) {
  switch (type) {
    case Listen::NONE: {
      return true;
    }
    case Listen::ListenIndividual: {
      auto ptr = reinterpret_cast<const FBS::WebRtcTransport::ListenIndividual *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Listen::ListenServer: {
      auto ptr = reinterpret_cast<const FBS::WebRtcTransport::ListenServer *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyListenVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<Listen> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyListen(
        verifier,  values->Get(i), types->GetEnum<Listen>(i))) {
      return false;
    }
  }
  return true;
}

inline const ::flatbuffers::TypeTable *ListenTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_SEQUENCE, 0, -1 },
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_SEQUENCE, 0, 1 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    FBS::WebRtcTransport::ListenIndividualTypeTable,
    FBS::WebRtcTransport::ListenServerTypeTable
  };
  static const char * const names[] = {
    "NONE",
    "ListenIndividual",
    "ListenServer"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_UNION, 3, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *IceStateTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_UCHAR, 0, 0 },
    { ::flatbuffers::ET_UCHAR, 0, 0 },
    { ::flatbuffers::ET_UCHAR, 0, 0 },
    { ::flatbuffers::ET_UCHAR, 0, 0 },
    { ::flatbuffers::ET_UCHAR, 0, 0 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    FBS::WebRtcTransport::IceStateTypeTable
  };
  static const char * const names[] = {
    "NEW",
    "CONNECTED",
    "COMPLETED",
    "DISCONNECTED",
    "CLOSED"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_ENUM, 5, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *DtlsStateTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_UCHAR, 0, 0 },
    { ::flatbuffers::ET_UCHAR, 0, 0 },
    { ::flatbuffers::ET_UCHAR, 0, 0 },
    { ::flatbuffers::ET_UCHAR, 0, 0 },
    { ::flatbuffers::ET_UCHAR, 0, 0 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    FBS::WebRtcTransport::DtlsStateTypeTable
  };
  static const char * const names[] = {
    "NEW",
    "CONNECTING",
    "CONNECTED",
    "FAILED",
    "CLOSED"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_ENUM, 5, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *ListenIndividualTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_SEQUENCE, 1, 0 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    FBS::Transport::ListenInfoTypeTable
  };
  static const char * const names[] = {
    "listenInfos"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *ListenServerTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_STRING, 0, -1 }
  };
  static const char * const names[] = {
    "webRtcServerId"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *WebRtcTransportOptionsTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_UTYPE, 0, 1 },
    { ::flatbuffers::ET_SEQUENCE, 0, 1 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    FBS::Transport::OptionsTypeTable,
    FBS::WebRtcTransport::ListenTypeTable
  };
  static const char * const names[] = {
    "base",
    "listen_type",
    "listen"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *FingerprintTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_STRING, 0, -1 }
  };
  static const char * const names[] = {
    "algorithm",
    "value"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *DtlsParametersTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_SEQUENCE, 1, 0 },
    { ::flatbuffers::ET_STRING, 0, -1 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    FBS::WebRtcTransport::FingerprintTypeTable
  };
  static const char * const names[] = {
    "fingerprints",
    "role"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *IceParametersTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_BOOL, 0, -1 }
  };
  static const char * const names[] = {
    "usernameFragment",
    "password",
    "iceLite"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 3, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *IceCandidateTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_UINT, 0, -1 },
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_UCHAR, 0, 0 },
    { ::flatbuffers::ET_USHORT, 0, -1 },
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_STRING, 0, -1 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    FBS::Transport::ProtocolTypeTable
  };
  static const char * const names[] = {
    "foundation",
    "priority",
    "ip",
    "protocol",
    "port",
    "type",
    "tcpType"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 7, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *ConnectRequestTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    FBS::WebRtcTransport::DtlsParametersTypeTable
  };
  static const char * const names[] = {
    "dtlsParameters"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *ConnectResponseTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_STRING, 0, -1 }
  };
  static const char * const names[] = {
    "dtlsLocalRole"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *DumpResponseTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_SEQUENCE, 0, 1 },
    { ::flatbuffers::ET_SEQUENCE, 1, 2 },
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_SEQUENCE, 0, 3 },
    { ::flatbuffers::ET_SEQUENCE, 0, 4 },
    { ::flatbuffers::ET_STRING, 0, -1 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    FBS::Transport::DumpTypeTable,
    FBS::WebRtcTransport::IceParametersTypeTable,
    FBS::WebRtcTransport::IceCandidateTypeTable,
    FBS::Transport::TupleTypeTable,
    FBS::WebRtcTransport::DtlsParametersTypeTable
  };
  static const char * const names[] = {
    "base",
    "iceRole",
    "iceParameters",
    "iceCandidates",
    "iceState",
    "iceSelectedTuple",
    "dtlsParameters",
    "dtlsState"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 8, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *GetStatsResponseTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_SEQUENCE, 0, 1 },
    { ::flatbuffers::ET_STRING, 0, -1 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    FBS::Transport::StatsTypeTable,
    FBS::Transport::TupleTypeTable
  };
  static const char * const names[] = {
    "base",
    "iceRole",
    "iceState",
    "iceSelectedTuple",
    "dtlsState"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 5, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *IceSelectedTupleChangeNotificationTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    FBS::Transport::TupleTypeTable
  };
  static const char * const names[] = {
    "tuple"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *IceStateChangeNotificationTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_UCHAR, 0, 0 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    FBS::WebRtcTransport::IceStateTypeTable
  };
  static const char * const names[] = {
    "iceState"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *DtlsStateChangeNotificationTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_UCHAR, 0, 0 },
    { ::flatbuffers::ET_STRING, 0, -1 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    FBS::WebRtcTransport::DtlsStateTypeTable
  };
  static const char * const names[] = {
    "dtlsState",
    "remoteCert"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

}  // namespace WebRtcTransport
}  // namespace FBS

#endif  // FLATBUFFERS_GENERATED_WEBRTCTRANSPORT_FBS_WEBRTCTRANSPORT_H_
