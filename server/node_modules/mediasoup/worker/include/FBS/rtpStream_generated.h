// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_RTPSTREAM_FBS_RTPSTREAM_H_
#define FLATBUFFERS_GENERATED_RTPSTREAM_FBS_RTPSTREAM_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 3,
             "Non-compatible flatbuffers version included");

#include "rtpParameters_generated.h"
#include "rtxStream_generated.h"

namespace FBS {
namespace RtpStream {

struct Params;
struct ParamsBuilder;

struct Dump;
struct DumpBuilder;

struct BitrateByLayer;
struct BitrateByLayerBuilder;

struct Stats;
struct StatsBuilder;

struct BaseStats;
struct BaseStatsBuilder;

struct RecvStats;
struct RecvStatsBuilder;

struct SendStats;
struct SendStatsBuilder;

inline const ::flatbuffers::TypeTable *ParamsTypeTable();

inline const ::flatbuffers::TypeTable *DumpTypeTable();

inline const ::flatbuffers::TypeTable *BitrateByLayerTypeTable();

inline const ::flatbuffers::TypeTable *StatsTypeTable();

inline const ::flatbuffers::TypeTable *BaseStatsTypeTable();

inline const ::flatbuffers::TypeTable *RecvStatsTypeTable();

inline const ::flatbuffers::TypeTable *SendStatsTypeTable();

enum class StatsData : uint8_t {
  NONE = 0,
  BaseStats = 1,
  RecvStats = 2,
  SendStats = 3,
  MIN = NONE,
  MAX = SendStats
};

inline const StatsData (&EnumValuesStatsData())[4] {
  static const StatsData values[] = {
    StatsData::NONE,
    StatsData::BaseStats,
    StatsData::RecvStats,
    StatsData::SendStats
  };
  return values;
}

inline const char * const *EnumNamesStatsData() {
  static const char * const names[5] = {
    "NONE",
    "BaseStats",
    "RecvStats",
    "SendStats",
    nullptr
  };
  return names;
}

inline const char *EnumNameStatsData(StatsData e) {
  if (::flatbuffers::IsOutRange(e, StatsData::NONE, StatsData::SendStats)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesStatsData()[index];
}

template<typename T> struct StatsDataTraits {
  static const StatsData enum_value = StatsData::NONE;
};

template<> struct StatsDataTraits<FBS::RtpStream::BaseStats> {
  static const StatsData enum_value = StatsData::BaseStats;
};

template<> struct StatsDataTraits<FBS::RtpStream::RecvStats> {
  static const StatsData enum_value = StatsData::RecvStats;
};

template<> struct StatsDataTraits<FBS::RtpStream::SendStats> {
  static const StatsData enum_value = StatsData::SendStats;
};

bool VerifyStatsData(::flatbuffers::Verifier &verifier, const void *obj, StatsData type);
bool VerifyStatsDataVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<StatsData> *types);

struct Params FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ParamsBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ParamsTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ENCODINGIDX = 4,
    VT_SSRC = 6,
    VT_PAYLOADTYPE = 8,
    VT_MIMETYPE = 10,
    VT_CLOCKRATE = 12,
    VT_RID = 14,
    VT_CNAME = 16,
    VT_RTXSSRC = 18,
    VT_RTXPAYLOADTYPE = 20,
    VT_USENACK = 22,
    VT_USEPLI = 24,
    VT_USEFIR = 26,
    VT_USEINBANDFEC = 28,
    VT_USEDTX = 30,
    VT_SPATIALLAYERS = 32,
    VT_TEMPORALLAYERS = 34
  };
  uint32_t encodingIdx() const {
    return GetField<uint32_t>(VT_ENCODINGIDX, 0);
  }
  uint32_t ssrc() const {
    return GetField<uint32_t>(VT_SSRC, 0);
  }
  uint8_t payloadType() const {
    return GetField<uint8_t>(VT_PAYLOADTYPE, 0);
  }
  const ::flatbuffers::String *mimeType() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MIMETYPE);
  }
  uint32_t clockRate() const {
    return GetField<uint32_t>(VT_CLOCKRATE, 0);
  }
  const ::flatbuffers::String *rid() const {
    return GetPointer<const ::flatbuffers::String *>(VT_RID);
  }
  const ::flatbuffers::String *cname() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CNAME);
  }
  ::flatbuffers::Optional<uint32_t> rtxSsrc() const {
    return GetOptional<uint32_t, uint32_t>(VT_RTXSSRC);
  }
  ::flatbuffers::Optional<uint8_t> rtxPayloadType() const {
    return GetOptional<uint8_t, uint8_t>(VT_RTXPAYLOADTYPE);
  }
  bool useNack() const {
    return GetField<uint8_t>(VT_USENACK, 0) != 0;
  }
  bool usePli() const {
    return GetField<uint8_t>(VT_USEPLI, 0) != 0;
  }
  bool useFir() const {
    return GetField<uint8_t>(VT_USEFIR, 0) != 0;
  }
  bool useInBandFec() const {
    return GetField<uint8_t>(VT_USEINBANDFEC, 0) != 0;
  }
  bool useDtx() const {
    return GetField<uint8_t>(VT_USEDTX, 0) != 0;
  }
  uint8_t spatialLayers() const {
    return GetField<uint8_t>(VT_SPATIALLAYERS, 0);
  }
  uint8_t temporalLayers() const {
    return GetField<uint8_t>(VT_TEMPORALLAYERS, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_ENCODINGIDX, 4) &&
           VerifyField<uint32_t>(verifier, VT_SSRC, 4) &&
           VerifyField<uint8_t>(verifier, VT_PAYLOADTYPE, 1) &&
           VerifyOffsetRequired(verifier, VT_MIMETYPE) &&
           verifier.VerifyString(mimeType()) &&
           VerifyField<uint32_t>(verifier, VT_CLOCKRATE, 4) &&
           VerifyOffset(verifier, VT_RID) &&
           verifier.VerifyString(rid()) &&
           VerifyOffsetRequired(verifier, VT_CNAME) &&
           verifier.VerifyString(cname()) &&
           VerifyField<uint32_t>(verifier, VT_RTXSSRC, 4) &&
           VerifyField<uint8_t>(verifier, VT_RTXPAYLOADTYPE, 1) &&
           VerifyField<uint8_t>(verifier, VT_USENACK, 1) &&
           VerifyField<uint8_t>(verifier, VT_USEPLI, 1) &&
           VerifyField<uint8_t>(verifier, VT_USEFIR, 1) &&
           VerifyField<uint8_t>(verifier, VT_USEINBANDFEC, 1) &&
           VerifyField<uint8_t>(verifier, VT_USEDTX, 1) &&
           VerifyField<uint8_t>(verifier, VT_SPATIALLAYERS, 1) &&
           VerifyField<uint8_t>(verifier, VT_TEMPORALLAYERS, 1) &&
           verifier.EndTable();
  }
};

struct ParamsBuilder {
  typedef Params Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_encodingIdx(uint32_t encodingIdx) {
    fbb_.AddElement<uint32_t>(Params::VT_ENCODINGIDX, encodingIdx, 0);
  }
  void add_ssrc(uint32_t ssrc) {
    fbb_.AddElement<uint32_t>(Params::VT_SSRC, ssrc, 0);
  }
  void add_payloadType(uint8_t payloadType) {
    fbb_.AddElement<uint8_t>(Params::VT_PAYLOADTYPE, payloadType, 0);
  }
  void add_mimeType(::flatbuffers::Offset<::flatbuffers::String> mimeType) {
    fbb_.AddOffset(Params::VT_MIMETYPE, mimeType);
  }
  void add_clockRate(uint32_t clockRate) {
    fbb_.AddElement<uint32_t>(Params::VT_CLOCKRATE, clockRate, 0);
  }
  void add_rid(::flatbuffers::Offset<::flatbuffers::String> rid) {
    fbb_.AddOffset(Params::VT_RID, rid);
  }
  void add_cname(::flatbuffers::Offset<::flatbuffers::String> cname) {
    fbb_.AddOffset(Params::VT_CNAME, cname);
  }
  void add_rtxSsrc(uint32_t rtxSsrc) {
    fbb_.AddElement<uint32_t>(Params::VT_RTXSSRC, rtxSsrc);
  }
  void add_rtxPayloadType(uint8_t rtxPayloadType) {
    fbb_.AddElement<uint8_t>(Params::VT_RTXPAYLOADTYPE, rtxPayloadType);
  }
  void add_useNack(bool useNack) {
    fbb_.AddElement<uint8_t>(Params::VT_USENACK, static_cast<uint8_t>(useNack), 0);
  }
  void add_usePli(bool usePli) {
    fbb_.AddElement<uint8_t>(Params::VT_USEPLI, static_cast<uint8_t>(usePli), 0);
  }
  void add_useFir(bool useFir) {
    fbb_.AddElement<uint8_t>(Params::VT_USEFIR, static_cast<uint8_t>(useFir), 0);
  }
  void add_useInBandFec(bool useInBandFec) {
    fbb_.AddElement<uint8_t>(Params::VT_USEINBANDFEC, static_cast<uint8_t>(useInBandFec), 0);
  }
  void add_useDtx(bool useDtx) {
    fbb_.AddElement<uint8_t>(Params::VT_USEDTX, static_cast<uint8_t>(useDtx), 0);
  }
  void add_spatialLayers(uint8_t spatialLayers) {
    fbb_.AddElement<uint8_t>(Params::VT_SPATIALLAYERS, spatialLayers, 0);
  }
  void add_temporalLayers(uint8_t temporalLayers) {
    fbb_.AddElement<uint8_t>(Params::VT_TEMPORALLAYERS, temporalLayers, 0);
  }
  explicit ParamsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Params> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Params>(end);
    fbb_.Required(o, Params::VT_MIMETYPE);
    fbb_.Required(o, Params::VT_CNAME);
    return o;
  }
};

inline ::flatbuffers::Offset<Params> CreateParams(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t encodingIdx = 0,
    uint32_t ssrc = 0,
    uint8_t payloadType = 0,
    ::flatbuffers::Offset<::flatbuffers::String> mimeType = 0,
    uint32_t clockRate = 0,
    ::flatbuffers::Offset<::flatbuffers::String> rid = 0,
    ::flatbuffers::Offset<::flatbuffers::String> cname = 0,
    ::flatbuffers::Optional<uint32_t> rtxSsrc = ::flatbuffers::nullopt,
    ::flatbuffers::Optional<uint8_t> rtxPayloadType = ::flatbuffers::nullopt,
    bool useNack = false,
    bool usePli = false,
    bool useFir = false,
    bool useInBandFec = false,
    bool useDtx = false,
    uint8_t spatialLayers = 0,
    uint8_t temporalLayers = 0) {
  ParamsBuilder builder_(_fbb);
  if(rtxSsrc) { builder_.add_rtxSsrc(*rtxSsrc); }
  builder_.add_cname(cname);
  builder_.add_rid(rid);
  builder_.add_clockRate(clockRate);
  builder_.add_mimeType(mimeType);
  builder_.add_ssrc(ssrc);
  builder_.add_encodingIdx(encodingIdx);
  builder_.add_temporalLayers(temporalLayers);
  builder_.add_spatialLayers(spatialLayers);
  builder_.add_useDtx(useDtx);
  builder_.add_useInBandFec(useInBandFec);
  builder_.add_useFir(useFir);
  builder_.add_usePli(usePli);
  builder_.add_useNack(useNack);
  if(rtxPayloadType) { builder_.add_rtxPayloadType(*rtxPayloadType); }
  builder_.add_payloadType(payloadType);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Params> CreateParamsDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t encodingIdx = 0,
    uint32_t ssrc = 0,
    uint8_t payloadType = 0,
    const char *mimeType = nullptr,
    uint32_t clockRate = 0,
    const char *rid = nullptr,
    const char *cname = nullptr,
    ::flatbuffers::Optional<uint32_t> rtxSsrc = ::flatbuffers::nullopt,
    ::flatbuffers::Optional<uint8_t> rtxPayloadType = ::flatbuffers::nullopt,
    bool useNack = false,
    bool usePli = false,
    bool useFir = false,
    bool useInBandFec = false,
    bool useDtx = false,
    uint8_t spatialLayers = 0,
    uint8_t temporalLayers = 0) {
  auto mimeType__ = mimeType ? _fbb.CreateString(mimeType) : 0;
  auto rid__ = rid ? _fbb.CreateString(rid) : 0;
  auto cname__ = cname ? _fbb.CreateString(cname) : 0;
  return FBS::RtpStream::CreateParams(
      _fbb,
      encodingIdx,
      ssrc,
      payloadType,
      mimeType__,
      clockRate,
      rid__,
      cname__,
      rtxSsrc,
      rtxPayloadType,
      useNack,
      usePli,
      useFir,
      useInBandFec,
      useDtx,
      spatialLayers,
      temporalLayers);
}

struct Dump FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DumpBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return DumpTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PARAMS = 4,
    VT_SCORE = 6,
    VT_RTXSTREAM = 8
  };
  const FBS::RtpStream::Params *params() const {
    return GetPointer<const FBS::RtpStream::Params *>(VT_PARAMS);
  }
  uint8_t score() const {
    return GetField<uint8_t>(VT_SCORE, 0);
  }
  const FBS::RtxStream::RtxDump *rtxStream() const {
    return GetPointer<const FBS::RtxStream::RtxDump *>(VT_RTXSTREAM);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_PARAMS) &&
           verifier.VerifyTable(params()) &&
           VerifyField<uint8_t>(verifier, VT_SCORE, 1) &&
           VerifyOffset(verifier, VT_RTXSTREAM) &&
           verifier.VerifyTable(rtxStream()) &&
           verifier.EndTable();
  }
};

struct DumpBuilder {
  typedef Dump Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_params(::flatbuffers::Offset<FBS::RtpStream::Params> params) {
    fbb_.AddOffset(Dump::VT_PARAMS, params);
  }
  void add_score(uint8_t score) {
    fbb_.AddElement<uint8_t>(Dump::VT_SCORE, score, 0);
  }
  void add_rtxStream(::flatbuffers::Offset<FBS::RtxStream::RtxDump> rtxStream) {
    fbb_.AddOffset(Dump::VT_RTXSTREAM, rtxStream);
  }
  explicit DumpBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Dump> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Dump>(end);
    fbb_.Required(o, Dump::VT_PARAMS);
    return o;
  }
};

inline ::flatbuffers::Offset<Dump> CreateDump(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<FBS::RtpStream::Params> params = 0,
    uint8_t score = 0,
    ::flatbuffers::Offset<FBS::RtxStream::RtxDump> rtxStream = 0) {
  DumpBuilder builder_(_fbb);
  builder_.add_rtxStream(rtxStream);
  builder_.add_params(params);
  builder_.add_score(score);
  return builder_.Finish();
}

struct BitrateByLayer FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BitrateByLayerBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return BitrateByLayerTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LAYER = 4,
    VT_BITRATE = 6
  };
  const ::flatbuffers::String *layer() const {
    return GetPointer<const ::flatbuffers::String *>(VT_LAYER);
  }
  uint64_t bitrate() const {
    return GetField<uint64_t>(VT_BITRATE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_LAYER) &&
           verifier.VerifyString(layer()) &&
           VerifyField<uint64_t>(verifier, VT_BITRATE, 8) &&
           verifier.EndTable();
  }
};

struct BitrateByLayerBuilder {
  typedef BitrateByLayer Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_layer(::flatbuffers::Offset<::flatbuffers::String> layer) {
    fbb_.AddOffset(BitrateByLayer::VT_LAYER, layer);
  }
  void add_bitrate(uint64_t bitrate) {
    fbb_.AddElement<uint64_t>(BitrateByLayer::VT_BITRATE, bitrate, 0);
  }
  explicit BitrateByLayerBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BitrateByLayer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BitrateByLayer>(end);
    fbb_.Required(o, BitrateByLayer::VT_LAYER);
    return o;
  }
};

inline ::flatbuffers::Offset<BitrateByLayer> CreateBitrateByLayer(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> layer = 0,
    uint64_t bitrate = 0) {
  BitrateByLayerBuilder builder_(_fbb);
  builder_.add_bitrate(bitrate);
  builder_.add_layer(layer);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<BitrateByLayer> CreateBitrateByLayerDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *layer = nullptr,
    uint64_t bitrate = 0) {
  auto layer__ = layer ? _fbb.CreateString(layer) : 0;
  return FBS::RtpStream::CreateBitrateByLayer(
      _fbb,
      layer__,
      bitrate);
}

struct Stats FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StatsBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return StatsTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATA_TYPE = 4,
    VT_DATA = 6
  };
  FBS::RtpStream::StatsData data_type() const {
    return static_cast<FBS::RtpStream::StatsData>(GetField<uint8_t>(VT_DATA_TYPE, 0));
  }
  const void *data() const {
    return GetPointer<const void *>(VT_DATA);
  }
  template<typename T> const T *data_as() const;
  const FBS::RtpStream::BaseStats *data_as_BaseStats() const {
    return data_type() == FBS::RtpStream::StatsData::BaseStats ? static_cast<const FBS::RtpStream::BaseStats *>(data()) : nullptr;
  }
  const FBS::RtpStream::RecvStats *data_as_RecvStats() const {
    return data_type() == FBS::RtpStream::StatsData::RecvStats ? static_cast<const FBS::RtpStream::RecvStats *>(data()) : nullptr;
  }
  const FBS::RtpStream::SendStats *data_as_SendStats() const {
    return data_type() == FBS::RtpStream::StatsData::SendStats ? static_cast<const FBS::RtpStream::SendStats *>(data()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_DATA_TYPE, 1) &&
           VerifyOffset(verifier, VT_DATA) &&
           VerifyStatsData(verifier, data(), data_type()) &&
           verifier.EndTable();
  }
};

template<> inline const FBS::RtpStream::BaseStats *Stats::data_as<FBS::RtpStream::BaseStats>() const {
  return data_as_BaseStats();
}

template<> inline const FBS::RtpStream::RecvStats *Stats::data_as<FBS::RtpStream::RecvStats>() const {
  return data_as_RecvStats();
}

template<> inline const FBS::RtpStream::SendStats *Stats::data_as<FBS::RtpStream::SendStats>() const {
  return data_as_SendStats();
}

struct StatsBuilder {
  typedef Stats Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_data_type(FBS::RtpStream::StatsData data_type) {
    fbb_.AddElement<uint8_t>(Stats::VT_DATA_TYPE, static_cast<uint8_t>(data_type), 0);
  }
  void add_data(::flatbuffers::Offset<void> data) {
    fbb_.AddOffset(Stats::VT_DATA, data);
  }
  explicit StatsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Stats> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Stats>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Stats> CreateStats(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    FBS::RtpStream::StatsData data_type = FBS::RtpStream::StatsData::NONE,
    ::flatbuffers::Offset<void> data = 0) {
  StatsBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_data_type(data_type);
  return builder_.Finish();
}

struct BaseStats FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BaseStatsBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return BaseStatsTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TIMESTAMP = 4,
    VT_SSRC = 6,
    VT_KIND = 8,
    VT_MIMETYPE = 10,
    VT_PACKETSLOST = 12,
    VT_FRACTIONLOST = 14,
    VT_PACKETSDISCARDED = 16,
    VT_PACKETSRETRANSMITTED = 18,
    VT_PACKETSREPAIRED = 20,
    VT_NACKCOUNT = 22,
    VT_NACKPACKETCOUNT = 24,
    VT_PLICOUNT = 26,
    VT_FIRCOUNT = 28,
    VT_SCORE = 30,
    VT_RID = 32,
    VT_RTXSSRC = 34,
    VT_RTXPACKETSDISCARDED = 36,
    VT_ROUNDTRIPTIME = 38
  };
  uint64_t timestamp() const {
    return GetField<uint64_t>(VT_TIMESTAMP, 0);
  }
  uint32_t ssrc() const {
    return GetField<uint32_t>(VT_SSRC, 0);
  }
  FBS::RtpParameters::MediaKind kind() const {
    return static_cast<FBS::RtpParameters::MediaKind>(GetField<uint8_t>(VT_KIND, 0));
  }
  const ::flatbuffers::String *mimeType() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MIMETYPE);
  }
  uint64_t packetsLost() const {
    return GetField<uint64_t>(VT_PACKETSLOST, 0);
  }
  uint64_t fractionLost() const {
    return GetField<uint64_t>(VT_FRACTIONLOST, 0);
  }
  uint64_t packetsDiscarded() const {
    return GetField<uint64_t>(VT_PACKETSDISCARDED, 0);
  }
  uint64_t packetsRetransmitted() const {
    return GetField<uint64_t>(VT_PACKETSRETRANSMITTED, 0);
  }
  uint64_t packetsRepaired() const {
    return GetField<uint64_t>(VT_PACKETSREPAIRED, 0);
  }
  uint64_t nackCount() const {
    return GetField<uint64_t>(VT_NACKCOUNT, 0);
  }
  uint64_t nackPacketCount() const {
    return GetField<uint64_t>(VT_NACKPACKETCOUNT, 0);
  }
  uint64_t pliCount() const {
    return GetField<uint64_t>(VT_PLICOUNT, 0);
  }
  uint64_t firCount() const {
    return GetField<uint64_t>(VT_FIRCOUNT, 0);
  }
  uint8_t score() const {
    return GetField<uint8_t>(VT_SCORE, 0);
  }
  const ::flatbuffers::String *rid() const {
    return GetPointer<const ::flatbuffers::String *>(VT_RID);
  }
  ::flatbuffers::Optional<uint32_t> rtxSsrc() const {
    return GetOptional<uint32_t, uint32_t>(VT_RTXSSRC);
  }
  uint64_t rtxPacketsDiscarded() const {
    return GetField<uint64_t>(VT_RTXPACKETSDISCARDED, 0);
  }
  float roundTripTime() const {
    return GetField<float>(VT_ROUNDTRIPTIME, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_TIMESTAMP, 8) &&
           VerifyField<uint32_t>(verifier, VT_SSRC, 4) &&
           VerifyField<uint8_t>(verifier, VT_KIND, 1) &&
           VerifyOffsetRequired(verifier, VT_MIMETYPE) &&
           verifier.VerifyString(mimeType()) &&
           VerifyField<uint64_t>(verifier, VT_PACKETSLOST, 8) &&
           VerifyField<uint64_t>(verifier, VT_FRACTIONLOST, 8) &&
           VerifyField<uint64_t>(verifier, VT_PACKETSDISCARDED, 8) &&
           VerifyField<uint64_t>(verifier, VT_PACKETSRETRANSMITTED, 8) &&
           VerifyField<uint64_t>(verifier, VT_PACKETSREPAIRED, 8) &&
           VerifyField<uint64_t>(verifier, VT_NACKCOUNT, 8) &&
           VerifyField<uint64_t>(verifier, VT_NACKPACKETCOUNT, 8) &&
           VerifyField<uint64_t>(verifier, VT_PLICOUNT, 8) &&
           VerifyField<uint64_t>(verifier, VT_FIRCOUNT, 8) &&
           VerifyField<uint8_t>(verifier, VT_SCORE, 1) &&
           VerifyOffset(verifier, VT_RID) &&
           verifier.VerifyString(rid()) &&
           VerifyField<uint32_t>(verifier, VT_RTXSSRC, 4) &&
           VerifyField<uint64_t>(verifier, VT_RTXPACKETSDISCARDED, 8) &&
           VerifyField<float>(verifier, VT_ROUNDTRIPTIME, 4) &&
           verifier.EndTable();
  }
};

struct BaseStatsBuilder {
  typedef BaseStats Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_timestamp(uint64_t timestamp) {
    fbb_.AddElement<uint64_t>(BaseStats::VT_TIMESTAMP, timestamp, 0);
  }
  void add_ssrc(uint32_t ssrc) {
    fbb_.AddElement<uint32_t>(BaseStats::VT_SSRC, ssrc, 0);
  }
  void add_kind(FBS::RtpParameters::MediaKind kind) {
    fbb_.AddElement<uint8_t>(BaseStats::VT_KIND, static_cast<uint8_t>(kind), 0);
  }
  void add_mimeType(::flatbuffers::Offset<::flatbuffers::String> mimeType) {
    fbb_.AddOffset(BaseStats::VT_MIMETYPE, mimeType);
  }
  void add_packetsLost(uint64_t packetsLost) {
    fbb_.AddElement<uint64_t>(BaseStats::VT_PACKETSLOST, packetsLost, 0);
  }
  void add_fractionLost(uint64_t fractionLost) {
    fbb_.AddElement<uint64_t>(BaseStats::VT_FRACTIONLOST, fractionLost, 0);
  }
  void add_packetsDiscarded(uint64_t packetsDiscarded) {
    fbb_.AddElement<uint64_t>(BaseStats::VT_PACKETSDISCARDED, packetsDiscarded, 0);
  }
  void add_packetsRetransmitted(uint64_t packetsRetransmitted) {
    fbb_.AddElement<uint64_t>(BaseStats::VT_PACKETSRETRANSMITTED, packetsRetransmitted, 0);
  }
  void add_packetsRepaired(uint64_t packetsRepaired) {
    fbb_.AddElement<uint64_t>(BaseStats::VT_PACKETSREPAIRED, packetsRepaired, 0);
  }
  void add_nackCount(uint64_t nackCount) {
    fbb_.AddElement<uint64_t>(BaseStats::VT_NACKCOUNT, nackCount, 0);
  }
  void add_nackPacketCount(uint64_t nackPacketCount) {
    fbb_.AddElement<uint64_t>(BaseStats::VT_NACKPACKETCOUNT, nackPacketCount, 0);
  }
  void add_pliCount(uint64_t pliCount) {
    fbb_.AddElement<uint64_t>(BaseStats::VT_PLICOUNT, pliCount, 0);
  }
  void add_firCount(uint64_t firCount) {
    fbb_.AddElement<uint64_t>(BaseStats::VT_FIRCOUNT, firCount, 0);
  }
  void add_score(uint8_t score) {
    fbb_.AddElement<uint8_t>(BaseStats::VT_SCORE, score, 0);
  }
  void add_rid(::flatbuffers::Offset<::flatbuffers::String> rid) {
    fbb_.AddOffset(BaseStats::VT_RID, rid);
  }
  void add_rtxSsrc(uint32_t rtxSsrc) {
    fbb_.AddElement<uint32_t>(BaseStats::VT_RTXSSRC, rtxSsrc);
  }
  void add_rtxPacketsDiscarded(uint64_t rtxPacketsDiscarded) {
    fbb_.AddElement<uint64_t>(BaseStats::VT_RTXPACKETSDISCARDED, rtxPacketsDiscarded, 0);
  }
  void add_roundTripTime(float roundTripTime) {
    fbb_.AddElement<float>(BaseStats::VT_ROUNDTRIPTIME, roundTripTime, 0.0f);
  }
  explicit BaseStatsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BaseStats> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BaseStats>(end);
    fbb_.Required(o, BaseStats::VT_MIMETYPE);
    return o;
  }
};

inline ::flatbuffers::Offset<BaseStats> CreateBaseStats(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t timestamp = 0,
    uint32_t ssrc = 0,
    FBS::RtpParameters::MediaKind kind = FBS::RtpParameters::MediaKind::ALL,
    ::flatbuffers::Offset<::flatbuffers::String> mimeType = 0,
    uint64_t packetsLost = 0,
    uint64_t fractionLost = 0,
    uint64_t packetsDiscarded = 0,
    uint64_t packetsRetransmitted = 0,
    uint64_t packetsRepaired = 0,
    uint64_t nackCount = 0,
    uint64_t nackPacketCount = 0,
    uint64_t pliCount = 0,
    uint64_t firCount = 0,
    uint8_t score = 0,
    ::flatbuffers::Offset<::flatbuffers::String> rid = 0,
    ::flatbuffers::Optional<uint32_t> rtxSsrc = ::flatbuffers::nullopt,
    uint64_t rtxPacketsDiscarded = 0,
    float roundTripTime = 0.0f) {
  BaseStatsBuilder builder_(_fbb);
  builder_.add_rtxPacketsDiscarded(rtxPacketsDiscarded);
  builder_.add_firCount(firCount);
  builder_.add_pliCount(pliCount);
  builder_.add_nackPacketCount(nackPacketCount);
  builder_.add_nackCount(nackCount);
  builder_.add_packetsRepaired(packetsRepaired);
  builder_.add_packetsRetransmitted(packetsRetransmitted);
  builder_.add_packetsDiscarded(packetsDiscarded);
  builder_.add_fractionLost(fractionLost);
  builder_.add_packetsLost(packetsLost);
  builder_.add_timestamp(timestamp);
  builder_.add_roundTripTime(roundTripTime);
  if(rtxSsrc) { builder_.add_rtxSsrc(*rtxSsrc); }
  builder_.add_rid(rid);
  builder_.add_mimeType(mimeType);
  builder_.add_ssrc(ssrc);
  builder_.add_score(score);
  builder_.add_kind(kind);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<BaseStats> CreateBaseStatsDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t timestamp = 0,
    uint32_t ssrc = 0,
    FBS::RtpParameters::MediaKind kind = FBS::RtpParameters::MediaKind::ALL,
    const char *mimeType = nullptr,
    uint64_t packetsLost = 0,
    uint64_t fractionLost = 0,
    uint64_t packetsDiscarded = 0,
    uint64_t packetsRetransmitted = 0,
    uint64_t packetsRepaired = 0,
    uint64_t nackCount = 0,
    uint64_t nackPacketCount = 0,
    uint64_t pliCount = 0,
    uint64_t firCount = 0,
    uint8_t score = 0,
    const char *rid = nullptr,
    ::flatbuffers::Optional<uint32_t> rtxSsrc = ::flatbuffers::nullopt,
    uint64_t rtxPacketsDiscarded = 0,
    float roundTripTime = 0.0f) {
  auto mimeType__ = mimeType ? _fbb.CreateString(mimeType) : 0;
  auto rid__ = rid ? _fbb.CreateString(rid) : 0;
  return FBS::RtpStream::CreateBaseStats(
      _fbb,
      timestamp,
      ssrc,
      kind,
      mimeType__,
      packetsLost,
      fractionLost,
      packetsDiscarded,
      packetsRetransmitted,
      packetsRepaired,
      nackCount,
      nackPacketCount,
      pliCount,
      firCount,
      score,
      rid__,
      rtxSsrc,
      rtxPacketsDiscarded,
      roundTripTime);
}

struct RecvStats FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RecvStatsBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return RecvStatsTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BASE = 4,
    VT_JITTER = 6,
    VT_PACKETCOUNT = 8,
    VT_BYTECOUNT = 10,
    VT_BITRATE = 12,
    VT_BITRATEBYLAYER = 14
  };
  const FBS::RtpStream::Stats *base() const {
    return GetPointer<const FBS::RtpStream::Stats *>(VT_BASE);
  }
  uint32_t jitter() const {
    return GetField<uint32_t>(VT_JITTER, 0);
  }
  uint64_t packetCount() const {
    return GetField<uint64_t>(VT_PACKETCOUNT, 0);
  }
  uint64_t byteCount() const {
    return GetField<uint64_t>(VT_BYTECOUNT, 0);
  }
  uint64_t bitrate() const {
    return GetField<uint64_t>(VT_BITRATE, 0);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<FBS::RtpStream::BitrateByLayer>> *bitrateByLayer() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<FBS::RtpStream::BitrateByLayer>> *>(VT_BITRATEBYLAYER);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_BASE) &&
           verifier.VerifyTable(base()) &&
           VerifyField<uint32_t>(verifier, VT_JITTER, 4) &&
           VerifyField<uint64_t>(verifier, VT_PACKETCOUNT, 8) &&
           VerifyField<uint64_t>(verifier, VT_BYTECOUNT, 8) &&
           VerifyField<uint64_t>(verifier, VT_BITRATE, 8) &&
           VerifyOffset(verifier, VT_BITRATEBYLAYER) &&
           verifier.VerifyVector(bitrateByLayer()) &&
           verifier.VerifyVectorOfTables(bitrateByLayer()) &&
           verifier.EndTable();
  }
};

struct RecvStatsBuilder {
  typedef RecvStats Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_base(::flatbuffers::Offset<FBS::RtpStream::Stats> base) {
    fbb_.AddOffset(RecvStats::VT_BASE, base);
  }
  void add_jitter(uint32_t jitter) {
    fbb_.AddElement<uint32_t>(RecvStats::VT_JITTER, jitter, 0);
  }
  void add_packetCount(uint64_t packetCount) {
    fbb_.AddElement<uint64_t>(RecvStats::VT_PACKETCOUNT, packetCount, 0);
  }
  void add_byteCount(uint64_t byteCount) {
    fbb_.AddElement<uint64_t>(RecvStats::VT_BYTECOUNT, byteCount, 0);
  }
  void add_bitrate(uint64_t bitrate) {
    fbb_.AddElement<uint64_t>(RecvStats::VT_BITRATE, bitrate, 0);
  }
  void add_bitrateByLayer(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<FBS::RtpStream::BitrateByLayer>>> bitrateByLayer) {
    fbb_.AddOffset(RecvStats::VT_BITRATEBYLAYER, bitrateByLayer);
  }
  explicit RecvStatsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RecvStats> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RecvStats>(end);
    fbb_.Required(o, RecvStats::VT_BASE);
    return o;
  }
};

inline ::flatbuffers::Offset<RecvStats> CreateRecvStats(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<FBS::RtpStream::Stats> base = 0,
    uint32_t jitter = 0,
    uint64_t packetCount = 0,
    uint64_t byteCount = 0,
    uint64_t bitrate = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<FBS::RtpStream::BitrateByLayer>>> bitrateByLayer = 0) {
  RecvStatsBuilder builder_(_fbb);
  builder_.add_bitrate(bitrate);
  builder_.add_byteCount(byteCount);
  builder_.add_packetCount(packetCount);
  builder_.add_bitrateByLayer(bitrateByLayer);
  builder_.add_jitter(jitter);
  builder_.add_base(base);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<RecvStats> CreateRecvStatsDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<FBS::RtpStream::Stats> base = 0,
    uint32_t jitter = 0,
    uint64_t packetCount = 0,
    uint64_t byteCount = 0,
    uint64_t bitrate = 0,
    const std::vector<::flatbuffers::Offset<FBS::RtpStream::BitrateByLayer>> *bitrateByLayer = nullptr) {
  auto bitrateByLayer__ = bitrateByLayer ? _fbb.CreateVector<::flatbuffers::Offset<FBS::RtpStream::BitrateByLayer>>(*bitrateByLayer) : 0;
  return FBS::RtpStream::CreateRecvStats(
      _fbb,
      base,
      jitter,
      packetCount,
      byteCount,
      bitrate,
      bitrateByLayer__);
}

struct SendStats FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SendStatsBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SendStatsTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BASE = 4,
    VT_PACKETCOUNT = 6,
    VT_BYTECOUNT = 8,
    VT_BITRATE = 10
  };
  const FBS::RtpStream::Stats *base() const {
    return GetPointer<const FBS::RtpStream::Stats *>(VT_BASE);
  }
  uint64_t packetCount() const {
    return GetField<uint64_t>(VT_PACKETCOUNT, 0);
  }
  uint64_t byteCount() const {
    return GetField<uint64_t>(VT_BYTECOUNT, 0);
  }
  uint64_t bitrate() const {
    return GetField<uint64_t>(VT_BITRATE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_BASE) &&
           verifier.VerifyTable(base()) &&
           VerifyField<uint64_t>(verifier, VT_PACKETCOUNT, 8) &&
           VerifyField<uint64_t>(verifier, VT_BYTECOUNT, 8) &&
           VerifyField<uint64_t>(verifier, VT_BITRATE, 8) &&
           verifier.EndTable();
  }
};

struct SendStatsBuilder {
  typedef SendStats Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_base(::flatbuffers::Offset<FBS::RtpStream::Stats> base) {
    fbb_.AddOffset(SendStats::VT_BASE, base);
  }
  void add_packetCount(uint64_t packetCount) {
    fbb_.AddElement<uint64_t>(SendStats::VT_PACKETCOUNT, packetCount, 0);
  }
  void add_byteCount(uint64_t byteCount) {
    fbb_.AddElement<uint64_t>(SendStats::VT_BYTECOUNT, byteCount, 0);
  }
  void add_bitrate(uint64_t bitrate) {
    fbb_.AddElement<uint64_t>(SendStats::VT_BITRATE, bitrate, 0);
  }
  explicit SendStatsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SendStats> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SendStats>(end);
    fbb_.Required(o, SendStats::VT_BASE);
    return o;
  }
};

inline ::flatbuffers::Offset<SendStats> CreateSendStats(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<FBS::RtpStream::Stats> base = 0,
    uint64_t packetCount = 0,
    uint64_t byteCount = 0,
    uint64_t bitrate = 0) {
  SendStatsBuilder builder_(_fbb);
  builder_.add_bitrate(bitrate);
  builder_.add_byteCount(byteCount);
  builder_.add_packetCount(packetCount);
  builder_.add_base(base);
  return builder_.Finish();
}

inline bool VerifyStatsData(::flatbuffers::Verifier &verifier, const void *obj, StatsData type) {
  switch (type) {
    case StatsData::NONE: {
      return true;
    }
    case StatsData::BaseStats: {
      auto ptr = reinterpret_cast<const FBS::RtpStream::BaseStats *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case StatsData::RecvStats: {
      auto ptr = reinterpret_cast<const FBS::RtpStream::RecvStats *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case StatsData::SendStats: {
      auto ptr = reinterpret_cast<const FBS::RtpStream::SendStats *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyStatsDataVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<StatsData> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyStatsData(
        verifier,  values->Get(i), types->GetEnum<StatsData>(i))) {
      return false;
    }
  }
  return true;
}

inline const ::flatbuffers::TypeTable *StatsDataTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_SEQUENCE, 0, -1 },
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_SEQUENCE, 0, 1 },
    { ::flatbuffers::ET_SEQUENCE, 0, 2 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    FBS::RtpStream::BaseStatsTypeTable,
    FBS::RtpStream::RecvStatsTypeTable,
    FBS::RtpStream::SendStatsTypeTable
  };
  static const char * const names[] = {
    "NONE",
    "BaseStats",
    "RecvStats",
    "SendStats"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_UNION, 4, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *ParamsTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_UINT, 0, -1 },
    { ::flatbuffers::ET_UINT, 0, -1 },
    { ::flatbuffers::ET_UCHAR, 0, -1 },
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_UINT, 0, -1 },
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_UINT, 0, -1 },
    { ::flatbuffers::ET_UCHAR, 0, -1 },
    { ::flatbuffers::ET_BOOL, 0, -1 },
    { ::flatbuffers::ET_BOOL, 0, -1 },
    { ::flatbuffers::ET_BOOL, 0, -1 },
    { ::flatbuffers::ET_BOOL, 0, -1 },
    { ::flatbuffers::ET_BOOL, 0, -1 },
    { ::flatbuffers::ET_UCHAR, 0, -1 },
    { ::flatbuffers::ET_UCHAR, 0, -1 }
  };
  static const char * const names[] = {
    "encodingIdx",
    "ssrc",
    "payloadType",
    "mimeType",
    "clockRate",
    "rid",
    "cname",
    "rtxSsrc",
    "rtxPayloadType",
    "useNack",
    "usePli",
    "useFir",
    "useInBandFec",
    "useDtx",
    "spatialLayers",
    "temporalLayers"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 16, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *DumpTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_UCHAR, 0, -1 },
    { ::flatbuffers::ET_SEQUENCE, 0, 1 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    FBS::RtpStream::ParamsTypeTable,
    FBS::RtxStream::RtxDumpTypeTable
  };
  static const char * const names[] = {
    "params",
    "score",
    "rtxStream"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *BitrateByLayerTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_ULONG, 0, -1 }
  };
  static const char * const names[] = {
    "layer",
    "bitrate"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *StatsTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_UTYPE, 0, 0 },
    { ::flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    FBS::RtpStream::StatsDataTypeTable
  };
  static const char * const names[] = {
    "data_type",
    "data"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *BaseStatsTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_ULONG, 0, -1 },
    { ::flatbuffers::ET_UINT, 0, -1 },
    { ::flatbuffers::ET_UCHAR, 0, 0 },
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_ULONG, 0, -1 },
    { ::flatbuffers::ET_ULONG, 0, -1 },
    { ::flatbuffers::ET_ULONG, 0, -1 },
    { ::flatbuffers::ET_ULONG, 0, -1 },
    { ::flatbuffers::ET_ULONG, 0, -1 },
    { ::flatbuffers::ET_ULONG, 0, -1 },
    { ::flatbuffers::ET_ULONG, 0, -1 },
    { ::flatbuffers::ET_ULONG, 0, -1 },
    { ::flatbuffers::ET_ULONG, 0, -1 },
    { ::flatbuffers::ET_UCHAR, 0, -1 },
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_UINT, 0, -1 },
    { ::flatbuffers::ET_ULONG, 0, -1 },
    { ::flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    FBS::RtpParameters::MediaKindTypeTable
  };
  static const char * const names[] = {
    "timestamp",
    "ssrc",
    "kind",
    "mimeType",
    "packetsLost",
    "fractionLost",
    "packetsDiscarded",
    "packetsRetransmitted",
    "packetsRepaired",
    "nackCount",
    "nackPacketCount",
    "pliCount",
    "firCount",
    "score",
    "rid",
    "rtxSsrc",
    "rtxPacketsDiscarded",
    "roundTripTime"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 18, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *RecvStatsTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, -1 },
    { ::flatbuffers::ET_ULONG, 0, -1 },
    { ::flatbuffers::ET_ULONG, 0, -1 },
    { ::flatbuffers::ET_ULONG, 0, -1 },
    { ::flatbuffers::ET_SEQUENCE, 1, 1 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    FBS::RtpStream::StatsTypeTable,
    FBS::RtpStream::BitrateByLayerTypeTable
  };
  static const char * const names[] = {
    "base",
    "jitter",
    "packetCount",
    "byteCount",
    "bitrate",
    "bitrateByLayer"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 6, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *SendStatsTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_ULONG, 0, -1 },
    { ::flatbuffers::ET_ULONG, 0, -1 },
    { ::flatbuffers::ET_ULONG, 0, -1 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    FBS::RtpStream::StatsTypeTable
  };
  static const char * const names[] = {
    "base",
    "packetCount",
    "byteCount",
    "bitrate"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 4, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

}  // namespace RtpStream
}  // namespace FBS

#endif  // FLATBUFFERS_GENERATED_RTPSTREAM_FBS_RTPSTREAM_H_
